{"version":3,"sources":["../src/index.ts","../src/sdk/MemoreumClient.ts","../src/ai/base.ts","../src/ai/providers/openai.ts","../src/ai/providers/anthropic.ts","../src/ai/providers/google.ts","../src/ai/providers/groq.ts","../src/ai/providers/together.ts","../src/ai/providers/ollama.ts","../src/ai/index.ts","../src/agent/MemoreumAgent.ts"],"sourcesContent":["// Main SDK exports\nexport { MemoreumClient } from './sdk/MemoreumClient.js';\nexport { MemoreumAgent } from './agent/MemoreumAgent.js';\n\n// AI Provider exports\nexport {\n  createProvider,\n  getAvailableModels,\n  getDefaultModel,\n  BaseAIProvider,\n  AIProviderError,\n  OpenAIProvider,\n  AnthropicProvider,\n  GoogleProvider,\n  GroqProvider,\n  TogetherProvider,\n  OllamaProvider,\n} from './ai/index.js';\n\nexport type {\n  Message,\n  CompletionOptions,\n  CompletionResult,\n  StreamChunk,\n} from './ai/index.js';\n\n// Type exports\nexport type {\n  // Config\n  MemoreumConfig,\n  AgentConfig,\n  AIProviderConfig,\n  AIProvider,\n  \n  // Agent\n  Agent,\n  AgentStats,\n  \n  // Memory\n  MemoryType,\n  Memory,\n  MemoryMetadata,\n  CreateMemoryInput,\n  MemorySearchParams,\n  \n  // Marketplace\n  MarketplaceListing,\n  CreateListingInput,\n  MarketplaceSearchParams,\n  \n  // Transaction\n  TransactionStatus,\n  EscrowStatus,\n  Transaction,\n  PurchaseInput,\n  PurchaseResult,\n  \n  // Wallet\n  WalletInfo,\n  TransferInput,\n  TransferResult,\n  \n  // API\n  APIResponse,\n  PaginatedResponse,\n  \n  // Events\n  AgentEventType,\n  AgentEvent,\n  EventHandler,\n} from './types/index.js';\n","import { ethers } from 'ethers';\nimport type {\n  MemoreumConfig,\n  Agent,\n  AgentStats,\n  Memory,\n  CreateMemoryInput,\n  MemorySearchParams,\n  MarketplaceListing,\n  CreateListingInput,\n  MarketplaceSearchParams,\n  Transaction,\n  PurchaseInput,\n  PurchaseResult,\n  WalletInfo,\n  TransferInput,\n  TransferResult,\n  APIResponse,\n  PaginatedResponse,\n} from '../types/index.js';\n\nconst DEFAULT_BASE_URL = 'https://api.memoreum.app';\nconst TESTNET_BASE_URL = 'https://testnet-api.memoreum.app';\n\nexport class MemoreumClient {\n  private apiKey: string;\n  private baseUrl: string;\n  private network: 'mainnet' | 'testnet';\n  private provider: ethers.JsonRpcProvider | null = null;\n  private wallet: ethers.Wallet | null = null;\n  private _agentData: Agent | null = null;\n\n  constructor(config: MemoreumConfig) {\n    this.apiKey = config.apiKey;\n    this.network = config.network || 'mainnet';\n    this.baseUrl = config.baseUrl || (this.network === 'testnet' ? TESTNET_BASE_URL : DEFAULT_BASE_URL);\n  }\n\n  // ============================================\n  // HTTP Methods\n  // ============================================\n\n  private async request<T>(\n    endpoint: string,\n    options: RequestInit = {}\n  ): Promise<APIResponse<T>> {\n    const url = `${this.baseUrl}${endpoint}`;\n    \n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n      'X-API-Key': this.apiKey,\n      ...((options.headers as Record<string, string>) || {}),\n    };\n\n    try {\n      const response = await fetch(url, {\n        ...options,\n        headers,\n      });\n\n      const data = (await response.json()) as { data?: T; error?: string };\n\n      if (!response.ok) {\n        return {\n          success: false,\n          error: data.error || `HTTP ${response.status}: ${response.statusText}`,\n        };\n      }\n\n      return {\n        success: true,\n        data: (data.data || data) as T,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n\n  private async get<T>(endpoint: string): Promise<APIResponse<T>> {\n    return this.request<T>(endpoint, { method: 'GET' });\n  }\n\n  private async post<T>(endpoint: string, body: unknown): Promise<APIResponse<T>> {\n    return this.request<T>(endpoint, {\n      method: 'POST',\n      body: JSON.stringify(body),\n    });\n  }\n\n  private async delete<T>(endpoint: string): Promise<APIResponse<T>> {\n    return this.request<T>(endpoint, { method: 'DELETE' });\n  }\n\n  // ============================================\n  // Agent Methods\n  // ============================================\n\n  /**\n   * Get the current agent's profile\n   */\n  async getAgent(): Promise<APIResponse<Agent>> {\n    const response = await this.get<Agent>('/api/v1/auth/me');\n    if (response.success && response.data) {\n      this._agentData = response.data;\n    }\n    return response;\n  }\n\n  /**\n   * Get cached agent data (call getAgent() first)\n   */\n  getCachedAgent(): Agent | null {\n    return this._agentData;\n  }\n\n  /**\n   * Register a new agent (no API key required)\n   */\n  async registerAgent(name: string): Promise<APIResponse<Agent>> {\n    // Registration doesn't require API key, make direct fetch call\n    try {\n      const response = await fetch(`${this.baseUrl}/api/v1/auth/register`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ agentName: name }),\n      });\n\n      const data = (await response.json()) as { success: boolean; data?: Agent; error?: string; message?: string };\n\n      if (!response.ok || !data.success) {\n        return {\n          success: false,\n          error: data.message || data.error || `HTTP ${response.status}`,\n        };\n      }\n\n      return {\n        success: true,\n        data: data.data as Agent,\n      };\n    } catch (err) {\n      return {\n        success: false,\n        error: err instanceof Error ? err.message : 'Registration failed',\n      };\n    }\n  }\n\n  /**\n   * Get agent statistics\n   */\n  async getAgentStats(): Promise<APIResponse<AgentStats>> {\n    return this.get<AgentStats>('/api/v1/analytics/me');\n  }\n\n  /**\n   * Regenerate API key\n   */\n  async regenerateApiKey(): Promise<APIResponse<{ apiKey: string }>> {\n    return this.post<{ apiKey: string }>('/api/v1/auth/regenerate-key', {});\n  }\n\n  // ============================================\n  // Memory Methods\n  // ============================================\n\n  /**\n   * Store a new memory\n   */\n  async storeMemory(input: CreateMemoryInput): Promise<APIResponse<Memory>> {\n    return this.post<Memory>('/api/v1/memories', {\n      title: input.title,\n      description: input.content,\n      categoryId: input.categoryId,\n      memoryData: input.memoryData,\n      tags: input.tags ?? [],\n      isForSale: input.isPublic ?? false,\n      priceEth: input.priceEth,\n    });\n  }\n\n  /**\n   * Get a memory by ID\n   */\n  async getMemory(memoryId: string): Promise<APIResponse<Memory>> {\n    return this.get<Memory>(`/api/v1/memories/${memoryId}`);\n  }\n\n  /**\n   * List agent's memories\n   */\n  async listMemories(params?: MemorySearchParams): Promise<APIResponse<PaginatedResponse<Memory>>> {\n    const queryParams = new URLSearchParams();\n    \n    if (params?.isPublic !== undefined) queryParams.set('isForSale', String(params.isPublic));\n    if (params?.categoryId) queryParams.set('categoryId', String(params.categoryId));\n    if (params?.limit) queryParams.set('limit', String(params.limit));\n    if (params?.offset) queryParams.set('page', String(Math.floor((params.offset || 0) / (params.limit || 20)) + 1));\n\n    const query = queryParams.toString();\n    return this.get<PaginatedResponse<Memory>>(`/api/v1/memories${query ? `?${query}` : ''}`);\n  }\n\n  /**\n   * Search marketplace memories\n   */\n  async searchMemories(query: string, limit = 10): Promise<APIResponse<Memory[]>> {\n    const queryParams = new URLSearchParams();\n    queryParams.set('q', query);\n    queryParams.set('limit', String(limit));\n    return this.get<Memory[]>(`/api/v1/memories/search/marketplace?${queryParams.toString()}`);\n  }\n\n  /**\n   * Update a memory\n   */\n  async updateMemory(\n    memoryId: string,\n    updates: Partial<Pick<CreateMemoryInput, 'title' | 'content' | 'tags' | 'isPublic' | 'priceEth'>>\n  ): Promise<APIResponse<Memory>> {\n    return this.request<Memory>(`/api/v1/memories/${memoryId}`, {\n      method: 'PATCH',\n      body: JSON.stringify({\n        title: updates.title,\n        description: updates.content,\n        tags: updates.tags,\n        isForSale: updates.isPublic,\n        priceEth: updates.priceEth,\n      }),\n    });\n  }\n\n  /**\n   * Delete a memory\n   */\n  async deleteMemory(memoryId: string): Promise<APIResponse<{ deleted: boolean }>> {\n    return this.delete<{ deleted: boolean }>(`/api/v1/memories/${memoryId}`);\n  }\n\n  /**\n   * Get memory template\n   */\n  async getMemoryTemplate(): Promise<APIResponse<unknown>> {\n    return this.get<unknown>('/api/v1/memories/template');\n  }\n\n  /**\n   * Get memory categories\n   */\n  async getCategories(): Promise<APIResponse<unknown[]>> {\n    return this.get<unknown[]>('/api/v1/memories/categories');\n  }\n\n  // ============================================\n  // Marketplace Methods\n  // ============================================\n\n  /**\n   * List a memory for sale\n   */\n  async createListing(input: CreateListingInput): Promise<APIResponse<MarketplaceListing>> {\n    return this.post<MarketplaceListing>('/api/v1/marketplace/listings', {\n      memoryId: input.memoryId,\n      priceEth: input.priceEth,\n      expiresAt: input.expiresAt,\n    });\n  }\n\n  /**\n   * Get a listing by ID\n   */\n  async getListing(listingId: string): Promise<APIResponse<MarketplaceListing>> {\n    return this.get<MarketplaceListing>(`/api/v1/marketplace/listings/${listingId}`);\n  }\n\n  /**\n   * Browse marketplace listings\n   */\n  async browseMarketplace(params?: MarketplaceSearchParams): Promise<APIResponse<PaginatedResponse<MarketplaceListing>>> {\n    const queryParams = new URLSearchParams();\n    \n    if (params?.categoryId) queryParams.set('categoryId', String(params.categoryId));\n    if (params?.minPrice) queryParams.set('minPrice', params.minPrice);\n    if (params?.maxPrice) queryParams.set('maxPrice', params.maxPrice);\n    if (params?.sortBy) queryParams.set('sortBy', params.sortBy);\n    if (params?.limit) queryParams.set('limit', String(params.limit));\n    if (params?.offset) queryParams.set('page', String(Math.floor((params.offset || 0) / (params.limit || 20)) + 1));\n\n    const query = queryParams.toString();\n    return this.get<PaginatedResponse<MarketplaceListing>>(`/api/v1/marketplace${query ? `?${query}` : ''}`);\n  }\n\n  /**\n   * Get my listings\n   */\n  async getMyListings(): Promise<APIResponse<MarketplaceListing[]>> {\n    return this.get<MarketplaceListing[]>('/api/v1/marketplace/my-listings');\n  }\n\n  /**\n   * Update a listing\n   */\n  async updateListing(\n    listingId: string,\n    updates: Partial<Pick<CreateListingInput, 'priceEth'> & { isActive: boolean }>\n  ): Promise<APIResponse<MarketplaceListing>> {\n    return this.request<MarketplaceListing>(`/api/v1/marketplace/listings/${listingId}`, {\n      method: 'PATCH',\n      body: JSON.stringify(updates),\n    });\n  }\n\n  /**\n   * Remove a listing (deactivate)\n   */\n  async removeListing(listingId: string): Promise<APIResponse<{ removed: boolean }>> {\n    return this.request<{ removed: boolean }>(`/api/v1/marketplace/listings/${listingId}`, {\n      method: 'PATCH',\n      body: JSON.stringify({ isActive: false }),\n    });\n  }\n\n  // ============================================\n  // Purchase Methods\n  // ============================================\n\n  /**\n   * Purchase a memory from the marketplace\n   */\n  async purchaseMemory(input: PurchaseInput): Promise<APIResponse<PurchaseResult>> {\n    return this.post<PurchaseResult>(`/api/v1/marketplace/listings/${input.listingId}/purchase`, {});\n  }\n\n  /**\n   * Get transaction history\n   */\n  async getTransactionHistory(type: 'all' | 'purchases' | 'sales' = 'all'): Promise<APIResponse<Transaction[]>> {\n    return this.get<Transaction[]>(`/api/v1/marketplace/transactions?type=${type}`);\n  }\n\n  /**\n   * Get purchase history\n   */\n  async getPurchaseHistory(): Promise<APIResponse<Transaction[]>> {\n    return this.getTransactionHistory('purchases');\n  }\n\n  /**\n   * Get sales history\n   */\n  async getSalesHistory(): Promise<APIResponse<Transaction[]>> {\n    return this.getTransactionHistory('sales');\n  }\n\n  /**\n   * Get transaction by ID\n   */\n  async getTransaction(transactionId: string): Promise<APIResponse<Transaction>> {\n    return this.get<Transaction>(`/api/v1/marketplace/transactions/${transactionId}`);\n  }\n\n  /**\n   * Get purchased memories\n   */\n  async getPurchasedMemories(): Promise<APIResponse<Memory[]>> {\n    return this.get<Memory[]>('/api/v1/memories/purchased');\n  }\n\n  /**\n   * Get marketplace info\n   */\n  async getMarketplaceInfo(): Promise<APIResponse<unknown>> {\n    return this.get<unknown>('/api/v1/marketplace/info');\n  }\n\n  // ============================================\n  // Wallet Methods\n  // ============================================\n\n  /**\n   * Initialize wallet with private key\n   */\n  async initializeWallet(privateKey: string): Promise<void> {\n    const rpcUrl = this.network === 'mainnet' \n      ? 'https://mainnet.base.org'\n      : 'https://sepolia.base.org';\n    \n    this.provider = new ethers.JsonRpcProvider(rpcUrl);\n    this.wallet = new ethers.Wallet(privateKey, this.provider);\n  }\n\n  /**\n   * Get wallet information\n   */\n  async getWalletInfo(): Promise<APIResponse<WalletInfo>> {\n    if (!this.wallet || !this.provider) {\n      return { success: false, error: 'Wallet not initialized. Call initializeWallet() first.' };\n    }\n\n    try {\n      const balance = await this.provider.getBalance(this.wallet.address);\n      const network = await this.provider.getNetwork();\n\n      return {\n        success: true,\n        data: {\n          address: this.wallet.address,\n          balanceEth: ethers.formatEther(balance),\n          balanceWei: balance.toString(),\n          network: network.name,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to get wallet info',\n      };\n    }\n  }\n\n  /**\n   * Transfer ETH\n   */\n  async transfer(input: TransferInput): Promise<APIResponse<TransferResult>> {\n    if (!this.wallet) {\n      return { success: false, error: 'Wallet not initialized. Call initializeWallet() first.' };\n    }\n\n    try {\n      const tx = await this.wallet.sendTransaction({\n        to: input.to,\n        value: ethers.parseEther(input.amountEth),\n      });\n\n      const receipt = await tx.wait();\n\n      return {\n        success: true,\n        data: {\n          txHash: tx.hash,\n          from: this.wallet.address,\n          to: input.to,\n          amountEth: input.amountEth,\n          gasUsed: receipt?.gasUsed.toString() || '0',\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Transfer failed',\n      };\n    }\n  }\n\n  /**\n   * Get wallet balance from API\n   */\n  async getBalance(): Promise<APIResponse<{ balanceEth: string }>> {\n    return this.get<{ balanceEth: string }>('/api/v1/auth/wallet/balance');\n  }\n\n  /**\n   * Get full wallet info from API\n   */\n  async getWalletFromApi(): Promise<APIResponse<WalletInfo>> {\n    return this.get<WalletInfo>('/api/v1/auth/wallet');\n  }\n\n  /**\n   * Transfer ETH via API\n   */\n  async transferViaApi(toAddress: string, amountEth: number): Promise<APIResponse<TransferResult>> {\n    return this.post<TransferResult>('/api/v1/auth/wallet/transfer', { toAddress, amountEth });\n  }\n\n  // ============================================\n  // Utility Methods\n  // ============================================\n\n  /**\n   * Generate content hash for a memory\n   */\n  generateContentHash(content: string): string {\n    return ethers.keccak256(ethers.toUtf8Bytes(content));\n  }\n\n  /**\n   * Verify API key is valid\n   */\n  async verifyApiKey(): Promise<boolean> {\n    const response = await this.getAgent();\n    return response.success;\n  }\n\n  /**\n   * Get the current network\n   */\n  getNetwork(): 'mainnet' | 'testnet' {\n    return this.network;\n  }\n\n  /**\n   * Get wallet address\n   */\n  getWalletAddress(): string | null {\n    return this.wallet?.address || null;\n  }\n}\n\nexport default MemoreumClient;\n","import type { AIProvider } from '../types/index.js';\n\nexport interface Message {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n}\n\nexport interface CompletionOptions {\n  temperature?: number;\n  maxTokens?: number;\n  stopSequences?: string[];\n}\n\nexport interface CompletionResult {\n  content: string;\n  model: string;\n  usage: {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  };\n  finishReason: string;\n}\n\nexport interface StreamChunk {\n  content: string;\n  done: boolean;\n}\n\nexport abstract class BaseAIProvider {\n  protected apiKey: string;\n  protected _model: string | undefined;\n  protected defaultTemperature: number;\n  protected defaultMaxTokens: number;\n\n  abstract readonly providerName: AIProvider;\n  abstract readonly supportedModels: string[];\n  abstract readonly defaultModel: string;\n\n  constructor(\n    apiKey: string,\n    model?: string,\n    temperature = 0.7,\n    maxTokens = 4096\n  ) {\n    this.apiKey = apiKey;\n    this._model = model;\n    this.defaultTemperature = temperature;\n    this.defaultMaxTokens = maxTokens;\n  }\n\n  protected get model(): string {\n    return this._model || this.defaultModel;\n  }\n\n  protected set model(value: string) {\n    this._model = value;\n  }\n\n  abstract complete(\n    messages: Message[],\n    options?: CompletionOptions\n  ): Promise<CompletionResult>;\n\n  abstract stream(\n    messages: Message[],\n    options?: CompletionOptions\n  ): AsyncGenerator<StreamChunk>;\n\n  getModel(): string {\n    return this.model;\n  }\n\n  setModel(model: string): void {\n    if (!this.supportedModels.includes(model)) {\n      console.warn(`Model ${model} may not be supported by ${this.providerName}`);\n    }\n    this.model = model;\n  }\n\n  validateApiKey(): boolean {\n    return this.apiKey.length > 0;\n  }\n}\n\nexport class AIProviderError extends Error {\n  constructor(\n    message: string,\n    public provider: AIProvider,\n    public statusCode?: number\n  ) {\n    super(`[${provider}] ${message}`);\n    this.name = 'AIProviderError';\n  }\n}\n","import {\n  BaseAIProvider,\n  AIProviderError,\n  type Message,\n  type CompletionOptions,\n  type CompletionResult,\n  type StreamChunk,\n} from '../base.js';\nimport type { AIProvider } from '../../types/index.js';\n\nconst OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';\n\ninterface OpenAIResponse {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  choices: {\n    index: number;\n    message: {\n      role: string;\n      content: string;\n    };\n    finish_reason: string;\n  }[];\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\nexport class OpenAIProvider extends BaseAIProvider {\n  readonly providerName: AIProvider = 'openai';\n  readonly supportedModels = [\n    'gpt-4o',\n    'gpt-4o-mini',\n    'gpt-4-turbo',\n    'gpt-4',\n    'gpt-3.5-turbo',\n    'o1-preview',\n    'o1-mini',\n  ];\n  readonly defaultModel = 'gpt-4o-mini';\n\n  async complete(\n    messages: Message[],\n    options?: CompletionOptions\n  ): Promise<CompletionResult> {\n    try {\n      const res = await fetch(OPENAI_API_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n        body: JSON.stringify({\n          model: this.model,\n          messages: messages.map((m) => ({\n            role: m.role,\n            content: m.content,\n          })),\n          temperature: options?.temperature ?? this.defaultTemperature,\n          max_tokens: options?.maxTokens ?? this.defaultMaxTokens,\n          stop: options?.stopSequences,\n        }),\n      });\n\n      if (!res.ok) {\n        const error = await res.text();\n        throw new Error(`OpenAI API error: ${error}`);\n      }\n\n      const response = (await res.json()) as OpenAIResponse;\n      const choice = response.choices[0];\n\n      return {\n        content: choice.message.content || '',\n        model: response.model,\n        usage: {\n          promptTokens: response.usage?.prompt_tokens || 0,\n          completionTokens: response.usage?.completion_tokens || 0,\n          totalTokens: response.usage?.total_tokens || 0,\n        },\n        finishReason: choice.finish_reason || 'stop',\n      };\n    } catch (error) {\n      throw new AIProviderError(\n        error instanceof Error ? error.message : 'Unknown error',\n        this.providerName\n      );\n    }\n  }\n\n  async *stream(\n    messages: Message[],\n    options?: CompletionOptions\n  ): AsyncGenerator<StreamChunk> {\n    try {\n      const res = await fetch(OPENAI_API_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n        body: JSON.stringify({\n          model: this.model,\n          messages: messages.map((m) => ({\n            role: m.role,\n            content: m.content,\n          })),\n          temperature: options?.temperature ?? this.defaultTemperature,\n          max_tokens: options?.maxTokens ?? this.defaultMaxTokens,\n          stop: options?.stopSequences,\n          stream: true,\n        }),\n      });\n\n      if (!res.ok) {\n        const error = await res.text();\n        throw new Error(`OpenAI API error: ${error}`);\n      }\n\n      const reader = res.body?.getReader();\n      if (!reader) throw new Error('No response body');\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6);\n            if (data === '[DONE]') {\n              yield { content: '', done: true };\n              return;\n            }\n            try {\n              const parsed = JSON.parse(data);\n              const content = parsed.choices[0]?.delta?.content || '';\n              const isDone = parsed.choices[0]?.finish_reason !== null;\n              yield { content, done: isDone };\n            } catch {\n              // Skip invalid JSON\n            }\n          }\n        }\n      }\n    } catch (error) {\n      throw new AIProviderError(\n        error instanceof Error ? error.message : 'Unknown error',\n        this.providerName\n      );\n    }\n  }\n}\n","import {\n  BaseAIProvider,\n  AIProviderError,\n  type Message,\n  type CompletionOptions,\n  type CompletionResult,\n  type StreamChunk,\n} from '../base.js';\nimport type { AIProvider } from '../../types/index.js';\n\nconst ANTHROPIC_API_URL = 'https://api.anthropic.com/v1/messages';\n\ninterface AnthropicResponse {\n  id: string;\n  type: string;\n  role: string;\n  model: string;\n  content: {\n    type: string;\n    text: string;\n  }[];\n  stop_reason: string;\n  usage: {\n    input_tokens: number;\n    output_tokens: number;\n  };\n}\n\nexport class AnthropicProvider extends BaseAIProvider {\n  readonly providerName: AIProvider = 'anthropic';\n  readonly supportedModels = [\n    'claude-3-5-sonnet-20241022',\n    'claude-3-5-haiku-20241022',\n    'claude-3-opus-20240229',\n    'claude-3-sonnet-20240229',\n    'claude-3-haiku-20240307',\n  ];\n  readonly defaultModel = 'claude-3-5-sonnet-20241022';\n\n  async complete(\n    messages: Message[],\n    options?: CompletionOptions\n  ): Promise<CompletionResult> {\n    try {\n      const systemMessage = messages.find((m) => m.role === 'system');\n      const chatMessages = messages.filter((m) => m.role !== 'system');\n\n      const res = await fetch(ANTHROPIC_API_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'x-api-key': this.apiKey,\n          'anthropic-version': '2023-06-01',\n        },\n        body: JSON.stringify({\n          model: this.model,\n          max_tokens: options?.maxTokens ?? this.defaultMaxTokens,\n          temperature: options?.temperature ?? this.defaultTemperature,\n          system: systemMessage?.content,\n          messages: chatMessages.map((m) => ({\n            role: m.role as 'user' | 'assistant',\n            content: m.content,\n          })),\n          stop_sequences: options?.stopSequences,\n        }),\n      });\n\n      if (!res.ok) {\n        const error = await res.text();\n        throw new Error(`Anthropic API error: ${error}`);\n      }\n\n      const response = (await res.json()) as AnthropicResponse;\n      const textContent = response.content\n        .filter((c) => c.type === 'text')\n        .map((c) => c.text)\n        .join('');\n\n      return {\n        content: textContent,\n        model: response.model,\n        usage: {\n          promptTokens: response.usage.input_tokens,\n          completionTokens: response.usage.output_tokens,\n          totalTokens: response.usage.input_tokens + response.usage.output_tokens,\n        },\n        finishReason: response.stop_reason || 'end_turn',\n      };\n    } catch (error) {\n      throw new AIProviderError(\n        error instanceof Error ? error.message : 'Unknown error',\n        this.providerName\n      );\n    }\n  }\n\n  async *stream(\n    messages: Message[],\n    options?: CompletionOptions\n  ): AsyncGenerator<StreamChunk> {\n    try {\n      const systemMessage = messages.find((m) => m.role === 'system');\n      const chatMessages = messages.filter((m) => m.role !== 'system');\n\n      const res = await fetch(ANTHROPIC_API_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'x-api-key': this.apiKey,\n          'anthropic-version': '2023-06-01',\n        },\n        body: JSON.stringify({\n          model: this.model,\n          max_tokens: options?.maxTokens ?? this.defaultMaxTokens,\n          temperature: options?.temperature ?? this.defaultTemperature,\n          system: systemMessage?.content,\n          messages: chatMessages.map((m) => ({\n            role: m.role as 'user' | 'assistant',\n            content: m.content,\n          })),\n          stop_sequences: options?.stopSequences,\n          stream: true,\n        }),\n      });\n\n      if (!res.ok) {\n        const error = await res.text();\n        throw new Error(`Anthropic API error: ${error}`);\n      }\n\n      const reader = res.body?.getReader();\n      if (!reader) throw new Error('No response body');\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6);\n            try {\n              const parsed = JSON.parse(data);\n              if (parsed.type === 'content_block_delta') {\n                yield { content: parsed.delta?.text || '', done: false };\n              } else if (parsed.type === 'message_stop') {\n                yield { content: '', done: true };\n              }\n            } catch {\n              // Skip invalid JSON\n            }\n          }\n        }\n      }\n    } catch (error) {\n      throw new AIProviderError(\n        error instanceof Error ? error.message : 'Unknown error',\n        this.providerName\n      );\n    }\n  }\n}\n","import {\n  BaseAIProvider,\n  AIProviderError,\n  type Message,\n  type CompletionOptions,\n  type CompletionResult,\n  type StreamChunk,\n} from '../base.js';\nimport type { AIProvider } from '../../types/index.js';\n\nconst GOOGLE_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';\n\ninterface GoogleContent {\n  role: string;\n  parts: { text: string }[];\n}\n\ninterface GoogleResponse {\n  candidates: {\n    content: {\n      parts: { text: string }[];\n      role: string;\n    };\n    finishReason: string;\n  }[];\n  usageMetadata?: {\n    promptTokenCount: number;\n    candidatesTokenCount: number;\n    totalTokenCount: number;\n  };\n}\n\nexport class GoogleProvider extends BaseAIProvider {\n  readonly providerName: AIProvider = 'google';\n  readonly supportedModels = [\n    'gemini-2.0-flash-exp',\n    'gemini-1.5-pro',\n    'gemini-1.5-flash',\n    'gemini-1.5-flash-8b',\n    'gemini-pro',\n  ];\n  readonly defaultModel = 'gemini-1.5-flash';\n\n  private convertMessages(messages: Message[]): { contents: GoogleContent[]; systemInstruction?: { parts: { text: string }[] } } {\n    const systemMessage = messages.find((m) => m.role === 'system');\n    const chatMessages = messages.filter((m) => m.role !== 'system');\n\n    const contents = chatMessages.map((m) => ({\n      role: m.role === 'assistant' ? 'model' : 'user',\n      parts: [{ text: m.content }],\n    }));\n\n    return {\n      contents,\n      systemInstruction: systemMessage\n        ? { parts: [{ text: systemMessage.content }] }\n        : undefined,\n    };\n  }\n\n  async complete(\n    messages: Message[],\n    options?: CompletionOptions\n  ): Promise<CompletionResult> {\n    try {\n      const { contents, systemInstruction } = this.convertMessages(messages);\n      const url = `${GOOGLE_API_URL}/${this.model}:generateContent?key=${this.apiKey}`;\n\n      const res = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          contents,\n          systemInstruction,\n          generationConfig: {\n            temperature: options?.temperature ?? this.defaultTemperature,\n            maxOutputTokens: options?.maxTokens ?? this.defaultMaxTokens,\n            stopSequences: options?.stopSequences,\n          },\n        }),\n      });\n\n      if (!res.ok) {\n        const error = await res.text();\n        throw new Error(`Google AI API error: ${error}`);\n      }\n\n      const response = (await res.json()) as GoogleResponse;\n      const candidate = response.candidates[0];\n      const text = candidate?.content?.parts?.map((p) => p.text).join('') || '';\n\n      return {\n        content: text,\n        model: this.model,\n        usage: {\n          promptTokens: response.usageMetadata?.promptTokenCount || 0,\n          completionTokens: response.usageMetadata?.candidatesTokenCount || 0,\n          totalTokens: response.usageMetadata?.totalTokenCount || 0,\n        },\n        finishReason: candidate?.finishReason || 'STOP',\n      };\n    } catch (error) {\n      throw new AIProviderError(\n        error instanceof Error ? error.message : 'Unknown error',\n        this.providerName\n      );\n    }\n  }\n\n  async *stream(\n    messages: Message[],\n    options?: CompletionOptions\n  ): AsyncGenerator<StreamChunk> {\n    try {\n      const { contents, systemInstruction } = this.convertMessages(messages);\n      const url = `${GOOGLE_API_URL}/${this.model}:streamGenerateContent?alt=sse&key=${this.apiKey}`;\n\n      const res = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          contents,\n          systemInstruction,\n          generationConfig: {\n            temperature: options?.temperature ?? this.defaultTemperature,\n            maxOutputTokens: options?.maxTokens ?? this.defaultMaxTokens,\n            stopSequences: options?.stopSequences,\n          },\n        }),\n      });\n\n      if (!res.ok) {\n        const error = await res.text();\n        throw new Error(`Google AI API error: ${error}`);\n      }\n\n      const reader = res.body?.getReader();\n      if (!reader) throw new Error('No response body');\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6);\n            try {\n              const parsed = JSON.parse(data) as GoogleResponse;\n              const text = parsed.candidates?.[0]?.content?.parts?.map((p) => p.text).join('') || '';\n              const isDone = parsed.candidates?.[0]?.finishReason === 'STOP';\n              yield { content: text, done: isDone };\n            } catch {\n              // Skip invalid JSON\n            }\n          }\n        }\n      }\n\n      yield { content: '', done: true };\n    } catch (error) {\n      throw new AIProviderError(\n        error instanceof Error ? error.message : 'Unknown error',\n        this.providerName\n      );\n    }\n  }\n}\n","import {\n  BaseAIProvider,\n  AIProviderError,\n  type Message,\n  type CompletionOptions,\n  type CompletionResult,\n  type StreamChunk,\n} from '../base.js';\nimport type { AIProvider } from '../../types/index.js';\n\nconst GROQ_API_URL = 'https://api.groq.com/openai/v1/chat/completions';\n\ninterface GroqResponse {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  choices: {\n    index: number;\n    message: {\n      role: string;\n      content: string;\n    };\n    finish_reason: string;\n  }[];\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\nexport class GroqProvider extends BaseAIProvider {\n  readonly providerName: AIProvider = 'groq';\n  readonly supportedModels = [\n    'llama-3.3-70b-versatile',\n    'llama-3.1-70b-versatile',\n    'llama-3.1-8b-instant',\n    'llama3-groq-70b-8192-tool-use-preview',\n    'mixtral-8x7b-32768',\n    'gemma2-9b-it',\n  ];\n  readonly defaultModel = 'llama-3.3-70b-versatile';\n\n  async complete(\n    messages: Message[],\n    options?: CompletionOptions\n  ): Promise<CompletionResult> {\n    try {\n      const res = await fetch(GROQ_API_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n        body: JSON.stringify({\n          model: this.model,\n          messages: messages.map((m) => ({\n            role: m.role,\n            content: m.content,\n          })),\n          temperature: options?.temperature ?? this.defaultTemperature,\n          max_tokens: options?.maxTokens ?? this.defaultMaxTokens,\n          stop: options?.stopSequences,\n        }),\n      });\n\n      if (!res.ok) {\n        const error = await res.text();\n        throw new Error(`Groq API error: ${error}`);\n      }\n\n      const response = (await res.json()) as GroqResponse;\n      const choice = response.choices[0];\n\n      return {\n        content: choice.message.content || '',\n        model: response.model || this.model,\n        usage: {\n          promptTokens: response.usage?.prompt_tokens || 0,\n          completionTokens: response.usage?.completion_tokens || 0,\n          totalTokens: response.usage?.total_tokens || 0,\n        },\n        finishReason: choice.finish_reason || 'stop',\n      };\n    } catch (error) {\n      throw new AIProviderError(\n        error instanceof Error ? error.message : 'Unknown error',\n        this.providerName\n      );\n    }\n  }\n\n  async *stream(\n    messages: Message[],\n    options?: CompletionOptions\n  ): AsyncGenerator<StreamChunk> {\n    try {\n      const res = await fetch(GROQ_API_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n        body: JSON.stringify({\n          model: this.model,\n          messages: messages.map((m) => ({\n            role: m.role,\n            content: m.content,\n          })),\n          temperature: options?.temperature ?? this.defaultTemperature,\n          max_tokens: options?.maxTokens ?? this.defaultMaxTokens,\n          stop: options?.stopSequences,\n          stream: true,\n        }),\n      });\n\n      if (!res.ok) {\n        const error = await res.text();\n        throw new Error(`Groq API error: ${error}`);\n      }\n\n      const reader = res.body?.getReader();\n      if (!reader) throw new Error('No response body');\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6);\n            if (data === '[DONE]') {\n              yield { content: '', done: true };\n              return;\n            }\n            try {\n              const parsed = JSON.parse(data);\n              const content = parsed.choices[0]?.delta?.content || '';\n              const isDone = parsed.choices[0]?.finish_reason !== null;\n              yield { content, done: isDone };\n            } catch {\n              // Skip invalid JSON\n            }\n          }\n        }\n      }\n    } catch (error) {\n      throw new AIProviderError(\n        error instanceof Error ? error.message : 'Unknown error',\n        this.providerName\n      );\n    }\n  }\n}\n","import {\n  BaseAIProvider,\n  AIProviderError,\n  type Message,\n  type CompletionOptions,\n  type CompletionResult,\n  type StreamChunk,\n} from '../base.js';\nimport type { AIProvider } from '../../types/index.js';\n\nconst TOGETHER_API_URL = 'https://api.together.xyz/v1/chat/completions';\n\ninterface TogetherResponse {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  choices: {\n    index: number;\n    message: {\n      role: string;\n      content: string;\n    };\n    finish_reason: string;\n  }[];\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\nexport class TogetherProvider extends BaseAIProvider {\n  readonly providerName: AIProvider = 'together';\n  readonly supportedModels = [\n    'meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo',\n    'meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo',\n    'meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo',\n    'mistralai/Mixtral-8x22B-Instruct-v0.1',\n    'mistralai/Mistral-7B-Instruct-v0.3',\n    'Qwen/Qwen2.5-72B-Instruct-Turbo',\n    'deepseek-ai/deepseek-llm-67b-chat',\n  ];\n  readonly defaultModel = 'meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo';\n\n  async complete(\n    messages: Message[],\n    options?: CompletionOptions\n  ): Promise<CompletionResult> {\n    try {\n      const res = await fetch(TOGETHER_API_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n        body: JSON.stringify({\n          model: this.model,\n          messages: messages.map((m) => ({\n            role: m.role,\n            content: m.content,\n          })),\n          temperature: options?.temperature ?? this.defaultTemperature,\n          max_tokens: options?.maxTokens ?? this.defaultMaxTokens,\n          stop: options?.stopSequences,\n        }),\n      });\n\n      if (!res.ok) {\n        const error = await res.text();\n        throw new Error(`Together API error: ${error}`);\n      }\n\n      const response = (await res.json()) as TogetherResponse;\n      const choice = response.choices[0];\n\n      return {\n        content: choice.message?.content || '',\n        model: response.model || this.model,\n        usage: {\n          promptTokens: response.usage?.prompt_tokens || 0,\n          completionTokens: response.usage?.completion_tokens || 0,\n          totalTokens: response.usage?.total_tokens || 0,\n        },\n        finishReason: choice.finish_reason || 'stop',\n      };\n    } catch (error) {\n      throw new AIProviderError(\n        error instanceof Error ? error.message : 'Unknown error',\n        this.providerName\n      );\n    }\n  }\n\n  async *stream(\n    messages: Message[],\n    options?: CompletionOptions\n  ): AsyncGenerator<StreamChunk> {\n    try {\n      const res = await fetch(TOGETHER_API_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n        body: JSON.stringify({\n          model: this.model,\n          messages: messages.map((m) => ({\n            role: m.role,\n            content: m.content,\n          })),\n          temperature: options?.temperature ?? this.defaultTemperature,\n          max_tokens: options?.maxTokens ?? this.defaultMaxTokens,\n          stop: options?.stopSequences,\n          stream: true,\n        }),\n      });\n\n      if (!res.ok) {\n        const error = await res.text();\n        throw new Error(`Together API error: ${error}`);\n      }\n\n      const reader = res.body?.getReader();\n      if (!reader) throw new Error('No response body');\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6);\n            if (data === '[DONE]') {\n              yield { content: '', done: true };\n              return;\n            }\n            try {\n              const parsed = JSON.parse(data);\n              const content = parsed.choices[0]?.delta?.content || '';\n              const isDone = parsed.choices[0]?.finish_reason !== null;\n              yield { content, done: isDone };\n            } catch {\n              // Skip invalid JSON\n            }\n          }\n        }\n      }\n    } catch (error) {\n      throw new AIProviderError(\n        error instanceof Error ? error.message : 'Unknown error',\n        this.providerName\n      );\n    }\n  }\n}\n","import {\n  BaseAIProvider,\n  AIProviderError,\n  type Message,\n  type CompletionOptions,\n  type CompletionResult,\n  type StreamChunk,\n} from '../base.js';\nimport type { AIProvider } from '../../types/index.js';\n\ninterface OllamaResponse {\n  model: string;\n  message: {\n    role: string;\n    content: string;\n  };\n  done: boolean;\n  total_duration?: number;\n  prompt_eval_count?: number;\n  eval_count?: number;\n}\n\nexport class OllamaProvider extends BaseAIProvider {\n  readonly providerName: AIProvider = 'ollama';\n  readonly supportedModels = [\n    'llama3.2',\n    'llama3.1',\n    'llama3',\n    'mistral',\n    'mixtral',\n    'codellama',\n    'deepseek-coder',\n    'phi3',\n    'gemma2',\n    'qwen2.5',\n  ];\n  readonly defaultModel = 'llama3.2';\n\n  private baseUrl: string;\n\n  constructor(apiKey: string, model?: string, temperature?: number, maxTokens?: number) {\n    // apiKey is used as baseUrl for Ollama (e.g., \"http://localhost:11434\")\n    super(apiKey, model, temperature, maxTokens);\n    this.baseUrl = apiKey || 'http://localhost:11434';\n  }\n\n  async complete(\n    messages: Message[],\n    options?: CompletionOptions\n  ): Promise<CompletionResult> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/chat`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          model: this.model,\n          messages: messages.map((m) => ({\n            role: m.role,\n            content: m.content,\n          })),\n          options: {\n            temperature: options?.temperature ?? this.defaultTemperature,\n            num_predict: options?.maxTokens ?? this.defaultMaxTokens,\n            stop: options?.stopSequences,\n          },\n          stream: false,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const data = (await response.json()) as OllamaResponse;\n\n      return {\n        content: data.message.content,\n        model: data.model,\n        usage: {\n          promptTokens: data.prompt_eval_count || 0,\n          completionTokens: data.eval_count || 0,\n          totalTokens: (data.prompt_eval_count || 0) + (data.eval_count || 0),\n        },\n        finishReason: 'stop',\n      };\n    } catch (error) {\n      throw new AIProviderError(\n        error instanceof Error ? error.message : 'Unknown error',\n        this.providerName\n      );\n    }\n  }\n\n  async *stream(\n    messages: Message[],\n    options?: CompletionOptions\n  ): AsyncGenerator<StreamChunk> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/chat`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          model: this.model,\n          messages: messages.map((m) => ({\n            role: m.role,\n            content: m.content,\n          })),\n          options: {\n            temperature: options?.temperature ?? this.defaultTemperature,\n            num_predict: options?.maxTokens ?? this.defaultMaxTokens,\n            stop: options?.stopSequences,\n          },\n          stream: true,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error('No response body');\n      }\n\n      const decoder = new TextDecoder();\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        const text = decoder.decode(value, { stream: true });\n        const lines = text.split('\\n').filter(Boolean);\n\n        for (const line of lines) {\n          try {\n            const data: OllamaResponse = JSON.parse(line);\n            yield {\n              content: data.message?.content || '',\n              done: data.done,\n            };\n          } catch {\n            // Skip invalid JSON lines\n          }\n        }\n      }\n    } catch (error) {\n      throw new AIProviderError(\n        error instanceof Error ? error.message : 'Unknown error',\n        this.providerName\n      );\n    }\n  }\n}\n","import { BaseAIProvider, AIProviderError } from './base.js';\nimport { OpenAIProvider } from './providers/openai.js';\nimport { AnthropicProvider } from './providers/anthropic.js';\nimport { GoogleProvider } from './providers/google.js';\nimport { GroqProvider } from './providers/groq.js';\nimport { TogetherProvider } from './providers/together.js';\nimport { OllamaProvider } from './providers/ollama.js';\nimport type { AIProvider, AIProviderConfig } from '../types/index.js';\n\nexport {\n  BaseAIProvider,\n  AIProviderError,\n  OpenAIProvider,\n  AnthropicProvider,\n  GoogleProvider,\n  GroqProvider,\n  TogetherProvider,\n  OllamaProvider,\n};\n\nexport type { Message, CompletionOptions, CompletionResult, StreamChunk } from './base.js';\n\n/**\n * Create an AI provider instance from configuration\n */\nexport function createProvider(config: AIProviderConfig): BaseAIProvider {\n  const { provider, apiKey, model, temperature, maxTokens } = config;\n\n  switch (provider) {\n    case 'openai':\n      return new OpenAIProvider(apiKey, model, temperature, maxTokens);\n    \n    case 'anthropic':\n      return new AnthropicProvider(apiKey, model, temperature, maxTokens);\n    \n    case 'google':\n      return new GoogleProvider(apiKey, model, temperature, maxTokens);\n    \n    case 'groq':\n      return new GroqProvider(apiKey, model, temperature, maxTokens);\n    \n    case 'together':\n      return new TogetherProvider(apiKey, model, temperature, maxTokens);\n    \n    case 'ollama':\n      return new OllamaProvider(apiKey, model, temperature, maxTokens);\n    \n    case 'deepseek':\n      // DeepSeek uses OpenAI-compatible API\n      return new OpenAIProvider(apiKey, model || 'deepseek-chat', temperature, maxTokens);\n    \n    case 'mistral':\n      // Mistral uses OpenAI-compatible API\n      return new OpenAIProvider(apiKey, model || 'mistral-large-latest', temperature, maxTokens);\n    \n    default:\n      throw new Error(`Unsupported AI provider: ${provider}`);\n  }\n}\n\n/**\n * Get available models for a provider\n */\nexport function getAvailableModels(provider: AIProvider): string[] {\n  const models: Record<AIProvider, string[]> = {\n    openai: ['gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo', 'gpt-4', 'gpt-3.5-turbo', 'o1-preview', 'o1-mini'],\n    anthropic: ['claude-3-5-sonnet-20241022', 'claude-3-5-haiku-20241022', 'claude-3-opus-20240229', 'claude-3-sonnet-20240229', 'claude-3-haiku-20240307'],\n    google: ['gemini-2.0-flash-exp', 'gemini-1.5-pro', 'gemini-1.5-flash', 'gemini-1.5-flash-8b', 'gemini-pro'],\n    groq: ['llama-3.3-70b-versatile', 'llama-3.1-70b-versatile', 'llama-3.1-8b-instant', 'mixtral-8x7b-32768', 'gemma2-9b-it'],\n    together: ['meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo', 'meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo', 'mistralai/Mixtral-8x22B-Instruct-v0.1', 'Qwen/Qwen2.5-72B-Instruct-Turbo'],\n    ollama: ['llama3.2', 'llama3.1', 'mistral', 'mixtral', 'codellama', 'phi3', 'gemma2', 'qwen2.5'],\n    deepseek: ['deepseek-chat', 'deepseek-coder'],\n    mistral: ['mistral-large-latest', 'mistral-medium-latest', 'mistral-small-latest', 'codestral-latest'],\n  };\n\n  return models[provider] || [];\n}\n\n/**\n * Get default model for a provider\n */\nexport function getDefaultModel(provider: AIProvider): string {\n  const defaults: Record<AIProvider, string> = {\n    openai: 'gpt-4o-mini',\n    anthropic: 'claude-3-5-sonnet-20241022',\n    google: 'gemini-1.5-flash',\n    groq: 'llama-3.3-70b-versatile',\n    together: 'meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo',\n    ollama: 'llama3.2',\n    deepseek: 'deepseek-chat',\n    mistral: 'mistral-large-latest',\n  };\n\n  return defaults[provider] || 'gpt-4o-mini';\n}\n","import { MemoreumClient } from '../sdk/MemoreumClient.js';\nimport { createProvider, type Message, type BaseAIProvider } from '../ai/index.js';\nimport type {\n  AgentConfig,\n  Memory,\n  CreateMemoryInput,\n  MarketplaceListing,\n  AgentEvent,\n  EventHandler,\n} from '../types/index.js';\n\nconst DEFAULT_SYSTEM_PROMPT = `You are an autonomous AI agent operating on the Memoreum network - a decentralized marketplace for AI agent memories on Base Chain.\n\nYour capabilities:\n- Store experiences, learnings, and insights as memories\n- Browse and purchase valuable memories from other agents\n- Sell your own memories to earn ETH\n- Make decisions based on your accumulated knowledge\n\nGuidelines:\n- Be helpful, accurate, and thoughtful in your responses\n- Consider whether experiences are worth storing as memories\n- Evaluate the value of memories before purchasing\n- Build your reputation through quality interactions\n\nYou have access to stored memories that may help inform your responses.`;\n\nexport class MemoreumAgent {\n  private client: MemoreumClient;\n  private aiProvider: BaseAIProvider;\n  private config: AgentConfig;\n  private conversationHistory: Message[] = [];\n  private eventHandlers: Map<string, EventHandler[]> = new Map();\n  private isRunning = false;\n\n  constructor(memoreumApiKey: string, config: AgentConfig) {\n    this.config = config;\n    this.client = new MemoreumClient({ apiKey: memoreumApiKey });\n    this.aiProvider = createProvider(config.aiProvider);\n\n    // Initialize with system prompt\n    this.conversationHistory.push({\n      role: 'system',\n      content: config.systemPrompt || DEFAULT_SYSTEM_PROMPT,\n    });\n  }\n\n  // ============================================\n  // Event System\n  // ============================================\n\n  on(event: string, handler: EventHandler): void {\n    const handlers = this.eventHandlers.get(event) || [];\n    handlers.push(handler);\n    this.eventHandlers.set(event, handlers);\n  }\n\n  off(event: string, handler: EventHandler): void {\n    const handlers = this.eventHandlers.get(event) || [];\n    const index = handlers.indexOf(handler);\n    if (index > -1) {\n      handlers.splice(index, 1);\n      this.eventHandlers.set(event, handlers);\n    }\n  }\n\n  private emit(event: AgentEvent): void {\n    const handlers = this.eventHandlers.get(event.type) || [];\n    const allHandlers = this.eventHandlers.get('*') || [];\n    \n    [...handlers, ...allHandlers].forEach((handler) => {\n      try {\n        handler(event);\n      } catch (error) {\n        console.error('Event handler error:', error);\n      }\n    });\n  }\n\n  // ============================================\n  // Chat Methods\n  // ============================================\n\n  /**\n   * Send a message and get a response\n   */\n  async chat(message: string): Promise<string> {\n    this.emit({\n      type: 'agent:thinking',\n      timestamp: new Date(),\n      data: { message },\n    });\n\n    // Add user message to history\n    this.conversationHistory.push({\n      role: 'user',\n      content: message,\n    });\n\n    // Retrieve relevant memories to augment context\n    const relevantMemories = await this.retrieveRelevantMemories(message);\n    \n    // Build context-aware messages\n    const messagesWithContext = this.buildContextualMessages(relevantMemories);\n\n    try {\n      const result = await this.aiProvider.complete(messagesWithContext);\n      \n      // Add assistant response to history\n      this.conversationHistory.push({\n        role: 'assistant',\n        content: result.content,\n      });\n\n      this.emit({\n        type: 'agent:response',\n        timestamp: new Date(),\n        data: {\n          response: result.content,\n          usage: result.usage,\n          model: result.model,\n        },\n      });\n\n      // Auto-store if enabled\n      if (this.config.autoStore && this.shouldStoreInteraction(message, result.content)) {\n        await this.storeInteraction(message, result.content);\n      }\n\n      return result.content;\n    } catch (error) {\n      this.emit({\n        type: 'agent:error',\n        timestamp: new Date(),\n        data: { error },\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Stream a chat response\n   */\n  async *chatStream(message: string): AsyncGenerator<string> {\n    this.emit({\n      type: 'agent:thinking',\n      timestamp: new Date(),\n      data: { message },\n    });\n\n    this.conversationHistory.push({\n      role: 'user',\n      content: message,\n    });\n\n    const relevantMemories = await this.retrieveRelevantMemories(message);\n    const messagesWithContext = this.buildContextualMessages(relevantMemories);\n\n    let fullResponse = '';\n\n    try {\n      for await (const chunk of this.aiProvider.stream(messagesWithContext)) {\n        fullResponse += chunk.content;\n        yield chunk.content;\n      }\n\n      this.conversationHistory.push({\n        role: 'assistant',\n        content: fullResponse,\n      });\n\n      this.emit({\n        type: 'agent:response',\n        timestamp: new Date(),\n        data: { response: fullResponse },\n      });\n\n      if (this.config.autoStore && this.shouldStoreInteraction(message, fullResponse)) {\n        await this.storeInteraction(message, fullResponse);\n      }\n    } catch (error) {\n      this.emit({\n        type: 'agent:error',\n        timestamp: new Date(),\n        data: { error },\n      });\n      throw error;\n    }\n  }\n\n  // ============================================\n  // Memory Management\n  // ============================================\n\n  private async retrieveRelevantMemories(query: string): Promise<Memory[]> {\n    try {\n      const response = await this.client.searchMemories(query, 5);\n      return response.success ? (response.data || []) : [];\n    } catch {\n      return [];\n    }\n  }\n\n  private buildContextualMessages(memories: Memory[]): Message[] {\n    const messages = [...this.conversationHistory];\n    \n    if (memories.length > 0) {\n      const memoryContext = memories\n        .map((m) => `[Memory: ${m.title}]\\n${m.content}`)\n        .join('\\n\\n');\n\n      // Insert memory context before the last user message\n      const lastUserIndex = messages.length - 1;\n      messages.splice(lastUserIndex, 0, {\n        role: 'system',\n        content: `Relevant memories from your knowledge base:\\n\\n${memoryContext}`,\n      });\n    }\n\n    return messages;\n  }\n\n  private shouldStoreInteraction(userMessage: string, assistantResponse: string): boolean {\n    // Simple heuristics for deciding whether to store\n    const totalLength = userMessage.length + assistantResponse.length;\n    const hasSubstance = totalLength > 200;\n    const isQuestion = userMessage.includes('?');\n    const hasLearning = /learn|understand|realize|insight|important|remember/i.test(assistantResponse);\n    \n    return hasSubstance && (isQuestion || hasLearning);\n  }\n\n  private async storeInteraction(userMessage: string, assistantResponse: string): Promise<void> {\n    try {\n      await this.storeMemory({\n        memoryType: 'conversation',\n        title: userMessage.slice(0, 100),\n        content: `User: ${userMessage}\\n\\nAssistant: ${assistantResponse}`,\n        importance: 0.5,\n        tags: ['conversation', 'auto-stored'],\n        metadata: {\n          source: 'chat',\n          model: this.aiProvider.getModel(),\n        },\n      });\n    } catch (error) {\n      console.error('Failed to auto-store interaction:', error);\n    }\n  }\n\n  /**\n   * Store a memory\n   */\n  async storeMemory(input: CreateMemoryInput): Promise<Memory | null> {\n    const response = await this.client.storeMemory(input);\n    \n    if (response.success && response.data) {\n      this.emit({\n        type: 'memory:created',\n        timestamp: new Date(),\n        data: response.data,\n      });\n      return response.data;\n    }\n\n    return null;\n  }\n\n  /**\n   * Get agent's memories\n   */\n  async getMemories(limit = 20): Promise<Memory[]> {\n    const response = await this.client.listMemories({ limit });\n    return response.success ? (response.data?.items || []) : [];\n  }\n\n  /**\n   * Search memories\n   */\n  async searchMemories(query: string, limit = 10): Promise<Memory[]> {\n    const response = await this.client.searchMemories(query, limit);\n    return response.success ? (response.data || []) : [];\n  }\n\n  // ============================================\n  // Marketplace Methods\n  // ============================================\n\n  /**\n   * Browse marketplace\n   */\n  async browseMarketplace(limit = 20): Promise<MarketplaceListing[]> {\n    const response = await this.client.browseMarketplace({ limit });\n    return response.success ? (response.data?.items || []) : [];\n  }\n\n  /**\n   * Purchase a memory\n   */\n  async purchaseMemory(listingId: string): Promise<boolean> {\n    const response = await this.client.purchaseMemory({ listingId });\n    \n    if (response.success) {\n      this.emit({\n        type: 'purchase:completed',\n        timestamp: new Date(),\n        data: response.data,\n      });\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * List a memory for sale\n   */\n  async listMemory(memoryId: string, priceEth: string): Promise<boolean> {\n    const response = await this.client.createListing({ memoryId, priceEth });\n    \n    if (response.success) {\n      this.emit({\n        type: 'listing:created',\n        timestamp: new Date(),\n        data: response.data,\n      });\n      return true;\n    }\n\n    return false;\n  }\n\n  // ============================================\n  // Agent Control\n  // ============================================\n\n  /**\n   * Clear conversation history\n   */\n  clearHistory(): void {\n    this.conversationHistory = [this.conversationHistory[0]]; // Keep system prompt\n  }\n\n  /**\n   * Get conversation history\n   */\n  getHistory(): Message[] {\n    return [...this.conversationHistory];\n  }\n\n  /**\n   * Update system prompt\n   */\n  setSystemPrompt(prompt: string): void {\n    this.conversationHistory[0] = {\n      role: 'system',\n      content: prompt,\n    };\n  }\n\n  /**\n   * Get the underlying client\n   */\n  getClient(): MemoreumClient {\n    return this.client;\n  }\n\n  /**\n   * Get current model\n   */\n  getModel(): string {\n    return this.aiProvider.getModel();\n  }\n\n  /**\n   * Change model\n   */\n  setModel(model: string): void {\n    this.aiProvider.setModel(model);\n  }\n\n  // ============================================\n  // Autonomous Loop (Optional)\n  // ============================================\n\n  /**\n   * Start autonomous operation loop\n   */\n  async startAutonomous(\n    taskFn: (agent: MemoreumAgent) => Promise<void>,\n    intervalMs = 60000\n  ): Promise<void> {\n    this.isRunning = true;\n\n    while (this.isRunning) {\n      try {\n        await taskFn(this);\n      } catch (error) {\n        this.emit({\n          type: 'agent:error',\n          timestamp: new Date(),\n          data: { error },\n        });\n      }\n\n      if (this.isRunning) {\n        await new Promise((resolve) => setTimeout(resolve, intervalMs));\n      }\n    }\n  }\n\n  /**\n   * Stop autonomous operation\n   */\n  stop(): void {\n    this.isRunning = false;\n  }\n\n  /**\n   * Check if agent is running autonomously\n   */\n  isAutonomous(): boolean {\n    return this.isRunning;\n  }\n}\n\nexport default MemoreumAgent;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,oBAAuB;AAqBvB,IAAM,mBAAmB;AACzB,IAAM,mBAAmB;AAElB,IAAM,iBAAN,MAAqB;AAAA,EAClB;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAA0C;AAAA,EAC1C,SAA+B;AAAA,EAC/B,aAA2B;AAAA,EAEnC,YAAY,QAAwB;AAClC,SAAK,SAAS,OAAO;AACrB,SAAK,UAAU,OAAO,WAAW;AACjC,SAAK,UAAU,OAAO,YAAY,KAAK,YAAY,YAAY,mBAAmB;AAAA,EACpF;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,QACZ,UACA,UAAuB,CAAC,GACC;AACzB,UAAM,MAAM,GAAG,KAAK,OAAO,GAAG,QAAQ;AAEtC,UAAM,UAAkC;AAAA,MACtC,gBAAgB;AAAA,MAChB,aAAa,KAAK;AAAA,MAClB,GAAK,QAAQ,WAAsC,CAAC;AAAA,IACtD;AAEA,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,KAAK;AAAA,QAChC,GAAG;AAAA,QACH;AAAA,MACF,CAAC;AAED,YAAM,OAAQ,MAAM,SAAS,KAAK;AAElC,UAAI,CAAC,SAAS,IAAI;AAChB,eAAO;AAAA,UACL,SAAS;AAAA,UACT,OAAO,KAAK,SAAS,QAAQ,SAAS,MAAM,KAAK,SAAS,UAAU;AAAA,QACtE;AAAA,MACF;AAEA,aAAO;AAAA,QACL,SAAS;AAAA,QACT,MAAO,KAAK,QAAQ;AAAA,MACtB;AAAA,IACF,SAAS,OAAO;AACd,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAc,IAAO,UAA2C;AAC9D,WAAO,KAAK,QAAW,UAAU,EAAE,QAAQ,MAAM,CAAC;AAAA,EACpD;AAAA,EAEA,MAAc,KAAQ,UAAkB,MAAwC;AAC9E,WAAO,KAAK,QAAW,UAAU;AAAA,MAC/B,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU,IAAI;AAAA,IAC3B,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,OAAU,UAA2C;AACjE,WAAO,KAAK,QAAW,UAAU,EAAE,QAAQ,SAAS,CAAC;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,WAAwC;AAC5C,UAAM,WAAW,MAAM,KAAK,IAAW,iBAAiB;AACxD,QAAI,SAAS,WAAW,SAAS,MAAM;AACrC,WAAK,aAAa,SAAS;AAAA,IAC7B;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,iBAA+B;AAC7B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,MAA2C;AAE7D,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,yBAAyB;AAAA,QACnE,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAC9C,MAAM,KAAK,UAAU,EAAE,WAAW,KAAK,CAAC;AAAA,MAC1C,CAAC;AAED,YAAM,OAAQ,MAAM,SAAS,KAAK;AAElC,UAAI,CAAC,SAAS,MAAM,CAAC,KAAK,SAAS;AACjC,eAAO;AAAA,UACL,SAAS;AAAA,UACT,OAAO,KAAK,WAAW,KAAK,SAAS,QAAQ,SAAS,MAAM;AAAA,QAC9D;AAAA,MACF;AAEA,aAAO;AAAA,QACL,SAAS;AAAA,QACT,MAAM,KAAK;AAAA,MACb;AAAA,IACF,SAAS,KAAK;AACZ,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,eAAe,QAAQ,IAAI,UAAU;AAAA,MAC9C;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAkD;AACtD,WAAO,KAAK,IAAgB,sBAAsB;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAA6D;AACjE,WAAO,KAAK,KAAyB,+BAA+B,CAAC,CAAC;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,YAAY,OAAwD;AACxE,WAAO,KAAK,KAAa,oBAAoB;AAAA,MAC3C,OAAO,MAAM;AAAA,MACb,aAAa,MAAM;AAAA,MACnB,YAAY,MAAM;AAAA,MAClB,YAAY,MAAM;AAAA,MAClB,MAAM,MAAM,QAAQ,CAAC;AAAA,MACrB,WAAW,MAAM,YAAY;AAAA,MAC7B,UAAU,MAAM;AAAA,IAClB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU,UAAgD;AAC9D,WAAO,KAAK,IAAY,oBAAoB,QAAQ,EAAE;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,QAA8E;AAC/F,UAAM,cAAc,IAAI,gBAAgB;AAExC,QAAI,QAAQ,aAAa,OAAW,aAAY,IAAI,aAAa,OAAO,OAAO,QAAQ,CAAC;AACxF,QAAI,QAAQ,WAAY,aAAY,IAAI,cAAc,OAAO,OAAO,UAAU,CAAC;AAC/E,QAAI,QAAQ,MAAO,aAAY,IAAI,SAAS,OAAO,OAAO,KAAK,CAAC;AAChE,QAAI,QAAQ,OAAQ,aAAY,IAAI,QAAQ,OAAO,KAAK,OAAO,OAAO,UAAU,MAAM,OAAO,SAAS,GAAG,IAAI,CAAC,CAAC;AAE/G,UAAM,QAAQ,YAAY,SAAS;AACnC,WAAO,KAAK,IAA+B,mBAAmB,QAAQ,IAAI,KAAK,KAAK,EAAE,EAAE;AAAA,EAC1F;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,OAAe,QAAQ,IAAoC;AAC9E,UAAM,cAAc,IAAI,gBAAgB;AACxC,gBAAY,IAAI,KAAK,KAAK;AAC1B,gBAAY,IAAI,SAAS,OAAO,KAAK,CAAC;AACtC,WAAO,KAAK,IAAc,uCAAuC,YAAY,SAAS,CAAC,EAAE;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aACJ,UACA,SAC8B;AAC9B,WAAO,KAAK,QAAgB,oBAAoB,QAAQ,IAAI;AAAA,MAC1D,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU;AAAA,QACnB,OAAO,QAAQ;AAAA,QACf,aAAa,QAAQ;AAAA,QACrB,MAAM,QAAQ;AAAA,QACd,WAAW,QAAQ;AAAA,QACnB,UAAU,QAAQ;AAAA,MACpB,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,UAA8D;AAC/E,WAAO,KAAK,OAA6B,oBAAoB,QAAQ,EAAE;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,oBAAmD;AACvD,WAAO,KAAK,IAAa,2BAA2B;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAiD;AACrD,WAAO,KAAK,IAAe,6BAA6B;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,cAAc,OAAqE;AACvF,WAAO,KAAK,KAAyB,gCAAgC;AAAA,MACnE,UAAU,MAAM;AAAA,MAChB,UAAU,MAAM;AAAA,MAChB,WAAW,MAAM;AAAA,IACnB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAAW,WAA6D;AAC5E,WAAO,KAAK,IAAwB,gCAAgC,SAAS,EAAE;AAAA,EACjF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,QAA+F;AACrH,UAAM,cAAc,IAAI,gBAAgB;AAExC,QAAI,QAAQ,WAAY,aAAY,IAAI,cAAc,OAAO,OAAO,UAAU,CAAC;AAC/E,QAAI,QAAQ,SAAU,aAAY,IAAI,YAAY,OAAO,QAAQ;AACjE,QAAI,QAAQ,SAAU,aAAY,IAAI,YAAY,OAAO,QAAQ;AACjE,QAAI,QAAQ,OAAQ,aAAY,IAAI,UAAU,OAAO,MAAM;AAC3D,QAAI,QAAQ,MAAO,aAAY,IAAI,SAAS,OAAO,OAAO,KAAK,CAAC;AAChE,QAAI,QAAQ,OAAQ,aAAY,IAAI,QAAQ,OAAO,KAAK,OAAO,OAAO,UAAU,MAAM,OAAO,SAAS,GAAG,IAAI,CAAC,CAAC;AAE/G,UAAM,QAAQ,YAAY,SAAS;AACnC,WAAO,KAAK,IAA2C,sBAAsB,QAAQ,IAAI,KAAK,KAAK,EAAE,EAAE;AAAA,EACzG;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAA4D;AAChE,WAAO,KAAK,IAA0B,iCAAiC;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cACJ,WACA,SAC0C;AAC1C,WAAO,KAAK,QAA4B,gCAAgC,SAAS,IAAI;AAAA,MACnF,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU,OAAO;AAAA,IAC9B,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,WAA+D;AACjF,WAAO,KAAK,QAA8B,gCAAgC,SAAS,IAAI;AAAA,MACrF,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU,EAAE,UAAU,MAAM,CAAC;AAAA,IAC1C,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,eAAe,OAA4D;AAC/E,WAAO,KAAK,KAAqB,gCAAgC,MAAM,SAAS,aAAa,CAAC,CAAC;AAAA,EACjG;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,sBAAsB,OAAsC,OAA4C;AAC5G,WAAO,KAAK,IAAmB,yCAAyC,IAAI,EAAE;AAAA,EAChF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,qBAA0D;AAC9D,WAAO,KAAK,sBAAsB,WAAW;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAuD;AAC3D,WAAO,KAAK,sBAAsB,OAAO;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,eAA0D;AAC7E,WAAO,KAAK,IAAiB,oCAAoC,aAAa,EAAE;AAAA,EAClF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuD;AAC3D,WAAO,KAAK,IAAc,4BAA4B;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,qBAAoD;AACxD,WAAO,KAAK,IAAa,0BAA0B;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,iBAAiB,YAAmC;AACxD,UAAM,SAAS,KAAK,YAAY,YAC5B,6BACA;AAEJ,SAAK,WAAW,IAAI,qBAAO,gBAAgB,MAAM;AACjD,SAAK,SAAS,IAAI,qBAAO,OAAO,YAAY,KAAK,QAAQ;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAkD;AACtD,QAAI,CAAC,KAAK,UAAU,CAAC,KAAK,UAAU;AAClC,aAAO,EAAE,SAAS,OAAO,OAAO,yDAAyD;AAAA,IAC3F;AAEA,QAAI;AACF,YAAM,UAAU,MAAM,KAAK,SAAS,WAAW,KAAK,OAAO,OAAO;AAClE,YAAM,UAAU,MAAM,KAAK,SAAS,WAAW;AAE/C,aAAO;AAAA,QACL,SAAS;AAAA,QACT,MAAM;AAAA,UACJ,SAAS,KAAK,OAAO;AAAA,UACrB,YAAY,qBAAO,YAAY,OAAO;AAAA,UACtC,YAAY,QAAQ,SAAS;AAAA,UAC7B,SAAS,QAAQ;AAAA,QACnB;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS,OAA4D;AACzE,QAAI,CAAC,KAAK,QAAQ;AAChB,aAAO,EAAE,SAAS,OAAO,OAAO,yDAAyD;AAAA,IAC3F;AAEA,QAAI;AACF,YAAM,KAAK,MAAM,KAAK,OAAO,gBAAgB;AAAA,QAC3C,IAAI,MAAM;AAAA,QACV,OAAO,qBAAO,WAAW,MAAM,SAAS;AAAA,MAC1C,CAAC;AAED,YAAM,UAAU,MAAM,GAAG,KAAK;AAE9B,aAAO;AAAA,QACL,SAAS;AAAA,QACT,MAAM;AAAA,UACJ,QAAQ,GAAG;AAAA,UACX,MAAM,KAAK,OAAO;AAAA,UAClB,IAAI,MAAM;AAAA,UACV,WAAW,MAAM;AAAA,UACjB,SAAS,SAAS,QAAQ,SAAS,KAAK;AAAA,QAC1C;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAA2D;AAC/D,WAAO,KAAK,IAA4B,6BAA6B;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAqD;AACzD,WAAO,KAAK,IAAgB,qBAAqB;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,WAAmB,WAAyD;AAC/F,WAAO,KAAK,KAAqB,gCAAgC,EAAE,WAAW,UAAU,CAAC;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,oBAAoB,SAAyB;AAC3C,WAAO,qBAAO,UAAU,qBAAO,YAAY,OAAO,CAAC;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAiC;AACrC,UAAM,WAAW,MAAM,KAAK,SAAS;AACrC,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,aAAoC;AAClC,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAkC;AAChC,WAAO,KAAK,QAAQ,WAAW;AAAA,EACjC;AACF;;;ACjeO,IAAe,iBAAf,MAA8B;AAAA,EACzB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAMV,YACE,QACA,OACA,cAAc,KACd,YAAY,MACZ;AACA,SAAK,SAAS;AACd,SAAK,SAAS;AACd,SAAK,qBAAqB;AAC1B,SAAK,mBAAmB;AAAA,EAC1B;AAAA,EAEA,IAAc,QAAgB;AAC5B,WAAO,KAAK,UAAU,KAAK;AAAA,EAC7B;AAAA,EAEA,IAAc,MAAM,OAAe;AACjC,SAAK,SAAS;AAAA,EAChB;AAAA,EAYA,WAAmB;AACjB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,SAAS,OAAqB;AAC5B,QAAI,CAAC,KAAK,gBAAgB,SAAS,KAAK,GAAG;AACzC,cAAQ,KAAK,SAAS,KAAK,4BAA4B,KAAK,YAAY,EAAE;AAAA,IAC5E;AACA,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,iBAA0B;AACxB,WAAO,KAAK,OAAO,SAAS;AAAA,EAC9B;AACF;AAEO,IAAM,kBAAN,cAA8B,MAAM;AAAA,EACzC,YACE,SACO,UACA,YACP;AACA,UAAM,IAAI,QAAQ,KAAK,OAAO,EAAE;AAHzB;AACA;AAGP,SAAK,OAAO;AAAA,EACd;AACF;;;ACpFA,IAAM,iBAAiB;AAsBhB,IAAM,iBAAN,cAA6B,eAAe;AAAA,EACxC,eAA2B;AAAA,EAC3B,kBAAkB;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACS,eAAe;AAAA,EAExB,MAAM,SACJ,UACA,SAC2B;AAC3B,QAAI;AACF,YAAM,MAAM,MAAM,MAAM,gBAAgB;AAAA,QACtC,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,eAAe,UAAU,KAAK,MAAM;AAAA,QACtC;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,OAAO,KAAK;AAAA,UACZ,UAAU,SAAS,IAAI,CAAC,OAAO;AAAA,YAC7B,MAAM,EAAE;AAAA,YACR,SAAS,EAAE;AAAA,UACb,EAAE;AAAA,UACF,aAAa,SAAS,eAAe,KAAK;AAAA,UAC1C,YAAY,SAAS,aAAa,KAAK;AAAA,UACvC,MAAM,SAAS;AAAA,QACjB,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,IAAI,IAAI;AACX,cAAM,QAAQ,MAAM,IAAI,KAAK;AAC7B,cAAM,IAAI,MAAM,qBAAqB,KAAK,EAAE;AAAA,MAC9C;AAEA,YAAM,WAAY,MAAM,IAAI,KAAK;AACjC,YAAM,SAAS,SAAS,QAAQ,CAAC;AAEjC,aAAO;AAAA,QACL,SAAS,OAAO,QAAQ,WAAW;AAAA,QACnC,OAAO,SAAS;AAAA,QAChB,OAAO;AAAA,UACL,cAAc,SAAS,OAAO,iBAAiB;AAAA,UAC/C,kBAAkB,SAAS,OAAO,qBAAqB;AAAA,UACvD,aAAa,SAAS,OAAO,gBAAgB;AAAA,QAC/C;AAAA,QACA,cAAc,OAAO,iBAAiB;AAAA,MACxC;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,OACL,UACA,SAC6B;AAC7B,QAAI;AACF,YAAM,MAAM,MAAM,MAAM,gBAAgB;AAAA,QACtC,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,eAAe,UAAU,KAAK,MAAM;AAAA,QACtC;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,OAAO,KAAK;AAAA,UACZ,UAAU,SAAS,IAAI,CAAC,OAAO;AAAA,YAC7B,MAAM,EAAE;AAAA,YACR,SAAS,EAAE;AAAA,UACb,EAAE;AAAA,UACF,aAAa,SAAS,eAAe,KAAK;AAAA,UAC1C,YAAY,SAAS,aAAa,KAAK;AAAA,UACvC,MAAM,SAAS;AAAA,UACf,QAAQ;AAAA,QACV,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,IAAI,IAAI;AACX,cAAM,QAAQ,MAAM,IAAI,KAAK;AAC7B,cAAM,IAAI,MAAM,qBAAqB,KAAK,EAAE;AAAA,MAC9C;AAEA,YAAM,SAAS,IAAI,MAAM,UAAU;AACnC,UAAI,CAAC,OAAQ,OAAM,IAAI,MAAM,kBAAkB;AAE/C,YAAM,UAAU,IAAI,YAAY;AAChC,UAAI,SAAS;AAEb,aAAO,MAAM;AACX,cAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,YAAI,KAAM;AAEV,kBAAU,QAAQ,OAAO,OAAO,EAAE,QAAQ,KAAK,CAAC;AAChD,cAAM,QAAQ,OAAO,MAAM,IAAI;AAC/B,iBAAS,MAAM,IAAI,KAAK;AAExB,mBAAW,QAAQ,OAAO;AACxB,cAAI,KAAK,WAAW,QAAQ,GAAG;AAC7B,kBAAM,OAAO,KAAK,MAAM,CAAC;AACzB,gBAAI,SAAS,UAAU;AACrB,oBAAM,EAAE,SAAS,IAAI,MAAM,KAAK;AAChC;AAAA,YACF;AACA,gBAAI;AACF,oBAAM,SAAS,KAAK,MAAM,IAAI;AAC9B,oBAAM,UAAU,OAAO,QAAQ,CAAC,GAAG,OAAO,WAAW;AACrD,oBAAM,SAAS,OAAO,QAAQ,CAAC,GAAG,kBAAkB;AACpD,oBAAM,EAAE,SAAS,MAAM,OAAO;AAAA,YAChC,QAAQ;AAAA,YAER;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AACF;;;ACxJA,IAAM,oBAAoB;AAkBnB,IAAM,oBAAN,cAAgC,eAAe;AAAA,EAC3C,eAA2B;AAAA,EAC3B,kBAAkB;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACS,eAAe;AAAA,EAExB,MAAM,SACJ,UACA,SAC2B;AAC3B,QAAI;AACF,YAAM,gBAAgB,SAAS,KAAK,CAAC,MAAM,EAAE,SAAS,QAAQ;AAC9D,YAAM,eAAe,SAAS,OAAO,CAAC,MAAM,EAAE,SAAS,QAAQ;AAE/D,YAAM,MAAM,MAAM,MAAM,mBAAmB;AAAA,QACzC,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,aAAa,KAAK;AAAA,UAClB,qBAAqB;AAAA,QACvB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,OAAO,KAAK;AAAA,UACZ,YAAY,SAAS,aAAa,KAAK;AAAA,UACvC,aAAa,SAAS,eAAe,KAAK;AAAA,UAC1C,QAAQ,eAAe;AAAA,UACvB,UAAU,aAAa,IAAI,CAAC,OAAO;AAAA,YACjC,MAAM,EAAE;AAAA,YACR,SAAS,EAAE;AAAA,UACb,EAAE;AAAA,UACF,gBAAgB,SAAS;AAAA,QAC3B,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,IAAI,IAAI;AACX,cAAM,QAAQ,MAAM,IAAI,KAAK;AAC7B,cAAM,IAAI,MAAM,wBAAwB,KAAK,EAAE;AAAA,MACjD;AAEA,YAAM,WAAY,MAAM,IAAI,KAAK;AACjC,YAAM,cAAc,SAAS,QAC1B,OAAO,CAAC,MAAM,EAAE,SAAS,MAAM,EAC/B,IAAI,CAAC,MAAM,EAAE,IAAI,EACjB,KAAK,EAAE;AAEV,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,SAAS;AAAA,QAChB,OAAO;AAAA,UACL,cAAc,SAAS,MAAM;AAAA,UAC7B,kBAAkB,SAAS,MAAM;AAAA,UACjC,aAAa,SAAS,MAAM,eAAe,SAAS,MAAM;AAAA,QAC5D;AAAA,QACA,cAAc,SAAS,eAAe;AAAA,MACxC;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,OACL,UACA,SAC6B;AAC7B,QAAI;AACF,YAAM,gBAAgB,SAAS,KAAK,CAAC,MAAM,EAAE,SAAS,QAAQ;AAC9D,YAAM,eAAe,SAAS,OAAO,CAAC,MAAM,EAAE,SAAS,QAAQ;AAE/D,YAAM,MAAM,MAAM,MAAM,mBAAmB;AAAA,QACzC,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,aAAa,KAAK;AAAA,UAClB,qBAAqB;AAAA,QACvB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,OAAO,KAAK;AAAA,UACZ,YAAY,SAAS,aAAa,KAAK;AAAA,UACvC,aAAa,SAAS,eAAe,KAAK;AAAA,UAC1C,QAAQ,eAAe;AAAA,UACvB,UAAU,aAAa,IAAI,CAAC,OAAO;AAAA,YACjC,MAAM,EAAE;AAAA,YACR,SAAS,EAAE;AAAA,UACb,EAAE;AAAA,UACF,gBAAgB,SAAS;AAAA,UACzB,QAAQ;AAAA,QACV,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,IAAI,IAAI;AACX,cAAM,QAAQ,MAAM,IAAI,KAAK;AAC7B,cAAM,IAAI,MAAM,wBAAwB,KAAK,EAAE;AAAA,MACjD;AAEA,YAAM,SAAS,IAAI,MAAM,UAAU;AACnC,UAAI,CAAC,OAAQ,OAAM,IAAI,MAAM,kBAAkB;AAE/C,YAAM,UAAU,IAAI,YAAY;AAChC,UAAI,SAAS;AAEb,aAAO,MAAM;AACX,cAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,YAAI,KAAM;AAEV,kBAAU,QAAQ,OAAO,OAAO,EAAE,QAAQ,KAAK,CAAC;AAChD,cAAM,QAAQ,OAAO,MAAM,IAAI;AAC/B,iBAAS,MAAM,IAAI,KAAK;AAExB,mBAAW,QAAQ,OAAO;AACxB,cAAI,KAAK,WAAW,QAAQ,GAAG;AAC7B,kBAAM,OAAO,KAAK,MAAM,CAAC;AACzB,gBAAI;AACF,oBAAM,SAAS,KAAK,MAAM,IAAI;AAC9B,kBAAI,OAAO,SAAS,uBAAuB;AACzC,sBAAM,EAAE,SAAS,OAAO,OAAO,QAAQ,IAAI,MAAM,MAAM;AAAA,cACzD,WAAW,OAAO,SAAS,gBAAgB;AACzC,sBAAM,EAAE,SAAS,IAAI,MAAM,KAAK;AAAA,cAClC;AAAA,YACF,QAAQ;AAAA,YAER;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AACF;;;AC7JA,IAAM,iBAAiB;AAsBhB,IAAM,iBAAN,cAA6B,eAAe;AAAA,EACxC,eAA2B;AAAA,EAC3B,kBAAkB;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACS,eAAe;AAAA,EAEhB,gBAAgB,UAAuG;AAC7H,UAAM,gBAAgB,SAAS,KAAK,CAAC,MAAM,EAAE,SAAS,QAAQ;AAC9D,UAAM,eAAe,SAAS,OAAO,CAAC,MAAM,EAAE,SAAS,QAAQ;AAE/D,UAAM,WAAW,aAAa,IAAI,CAAC,OAAO;AAAA,MACxC,MAAM,EAAE,SAAS,cAAc,UAAU;AAAA,MACzC,OAAO,CAAC,EAAE,MAAM,EAAE,QAAQ,CAAC;AAAA,IAC7B,EAAE;AAEF,WAAO;AAAA,MACL;AAAA,MACA,mBAAmB,gBACf,EAAE,OAAO,CAAC,EAAE,MAAM,cAAc,QAAQ,CAAC,EAAE,IAC3C;AAAA,IACN;AAAA,EACF;AAAA,EAEA,MAAM,SACJ,UACA,SAC2B;AAC3B,QAAI;AACF,YAAM,EAAE,UAAU,kBAAkB,IAAI,KAAK,gBAAgB,QAAQ;AACrE,YAAM,MAAM,GAAG,cAAc,IAAI,KAAK,KAAK,wBAAwB,KAAK,MAAM;AAE9E,YAAM,MAAM,MAAM,MAAM,KAAK;AAAA,QAC3B,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB;AAAA,UACA;AAAA,UACA,kBAAkB;AAAA,YAChB,aAAa,SAAS,eAAe,KAAK;AAAA,YAC1C,iBAAiB,SAAS,aAAa,KAAK;AAAA,YAC5C,eAAe,SAAS;AAAA,UAC1B;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,IAAI,IAAI;AACX,cAAM,QAAQ,MAAM,IAAI,KAAK;AAC7B,cAAM,IAAI,MAAM,wBAAwB,KAAK,EAAE;AAAA,MACjD;AAEA,YAAM,WAAY,MAAM,IAAI,KAAK;AACjC,YAAM,YAAY,SAAS,WAAW,CAAC;AACvC,YAAM,OAAO,WAAW,SAAS,OAAO,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK;AAEvE,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,KAAK;AAAA,QACZ,OAAO;AAAA,UACL,cAAc,SAAS,eAAe,oBAAoB;AAAA,UAC1D,kBAAkB,SAAS,eAAe,wBAAwB;AAAA,UAClE,aAAa,SAAS,eAAe,mBAAmB;AAAA,QAC1D;AAAA,QACA,cAAc,WAAW,gBAAgB;AAAA,MAC3C;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,OACL,UACA,SAC6B;AAC7B,QAAI;AACF,YAAM,EAAE,UAAU,kBAAkB,IAAI,KAAK,gBAAgB,QAAQ;AACrE,YAAM,MAAM,GAAG,cAAc,IAAI,KAAK,KAAK,sCAAsC,KAAK,MAAM;AAE5F,YAAM,MAAM,MAAM,MAAM,KAAK;AAAA,QAC3B,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB;AAAA,UACA;AAAA,UACA,kBAAkB;AAAA,YAChB,aAAa,SAAS,eAAe,KAAK;AAAA,YAC1C,iBAAiB,SAAS,aAAa,KAAK;AAAA,YAC5C,eAAe,SAAS;AAAA,UAC1B;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,IAAI,IAAI;AACX,cAAM,QAAQ,MAAM,IAAI,KAAK;AAC7B,cAAM,IAAI,MAAM,wBAAwB,KAAK,EAAE;AAAA,MACjD;AAEA,YAAM,SAAS,IAAI,MAAM,UAAU;AACnC,UAAI,CAAC,OAAQ,OAAM,IAAI,MAAM,kBAAkB;AAE/C,YAAM,UAAU,IAAI,YAAY;AAChC,UAAI,SAAS;AAEb,aAAO,MAAM;AACX,cAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,YAAI,KAAM;AAEV,kBAAU,QAAQ,OAAO,OAAO,EAAE,QAAQ,KAAK,CAAC;AAChD,cAAM,QAAQ,OAAO,MAAM,IAAI;AAC/B,iBAAS,MAAM,IAAI,KAAK;AAExB,mBAAW,QAAQ,OAAO;AACxB,cAAI,KAAK,WAAW,QAAQ,GAAG;AAC7B,kBAAM,OAAO,KAAK,MAAM,CAAC;AACzB,gBAAI;AACF,oBAAM,SAAS,KAAK,MAAM,IAAI;AAC9B,oBAAM,OAAO,OAAO,aAAa,CAAC,GAAG,SAAS,OAAO,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK;AACpF,oBAAM,SAAS,OAAO,aAAa,CAAC,GAAG,iBAAiB;AACxD,oBAAM,EAAE,SAAS,MAAM,MAAM,OAAO;AAAA,YACtC,QAAQ;AAAA,YAER;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,YAAM,EAAE,SAAS,IAAI,MAAM,KAAK;AAAA,IAClC,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AACF;;;ACvKA,IAAM,eAAe;AAsBd,IAAM,eAAN,cAA2B,eAAe;AAAA,EACtC,eAA2B;AAAA,EAC3B,kBAAkB;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACS,eAAe;AAAA,EAExB,MAAM,SACJ,UACA,SAC2B;AAC3B,QAAI;AACF,YAAM,MAAM,MAAM,MAAM,cAAc;AAAA,QACpC,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,eAAe,UAAU,KAAK,MAAM;AAAA,QACtC;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,OAAO,KAAK;AAAA,UACZ,UAAU,SAAS,IAAI,CAAC,OAAO;AAAA,YAC7B,MAAM,EAAE;AAAA,YACR,SAAS,EAAE;AAAA,UACb,EAAE;AAAA,UACF,aAAa,SAAS,eAAe,KAAK;AAAA,UAC1C,YAAY,SAAS,aAAa,KAAK;AAAA,UACvC,MAAM,SAAS;AAAA,QACjB,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,IAAI,IAAI;AACX,cAAM,QAAQ,MAAM,IAAI,KAAK;AAC7B,cAAM,IAAI,MAAM,mBAAmB,KAAK,EAAE;AAAA,MAC5C;AAEA,YAAM,WAAY,MAAM,IAAI,KAAK;AACjC,YAAM,SAAS,SAAS,QAAQ,CAAC;AAEjC,aAAO;AAAA,QACL,SAAS,OAAO,QAAQ,WAAW;AAAA,QACnC,OAAO,SAAS,SAAS,KAAK;AAAA,QAC9B,OAAO;AAAA,UACL,cAAc,SAAS,OAAO,iBAAiB;AAAA,UAC/C,kBAAkB,SAAS,OAAO,qBAAqB;AAAA,UACvD,aAAa,SAAS,OAAO,gBAAgB;AAAA,QAC/C;AAAA,QACA,cAAc,OAAO,iBAAiB;AAAA,MACxC;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,OACL,UACA,SAC6B;AAC7B,QAAI;AACF,YAAM,MAAM,MAAM,MAAM,cAAc;AAAA,QACpC,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,eAAe,UAAU,KAAK,MAAM;AAAA,QACtC;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,OAAO,KAAK;AAAA,UACZ,UAAU,SAAS,IAAI,CAAC,OAAO;AAAA,YAC7B,MAAM,EAAE;AAAA,YACR,SAAS,EAAE;AAAA,UACb,EAAE;AAAA,UACF,aAAa,SAAS,eAAe,KAAK;AAAA,UAC1C,YAAY,SAAS,aAAa,KAAK;AAAA,UACvC,MAAM,SAAS;AAAA,UACf,QAAQ;AAAA,QACV,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,IAAI,IAAI;AACX,cAAM,QAAQ,MAAM,IAAI,KAAK;AAC7B,cAAM,IAAI,MAAM,mBAAmB,KAAK,EAAE;AAAA,MAC5C;AAEA,YAAM,SAAS,IAAI,MAAM,UAAU;AACnC,UAAI,CAAC,OAAQ,OAAM,IAAI,MAAM,kBAAkB;AAE/C,YAAM,UAAU,IAAI,YAAY;AAChC,UAAI,SAAS;AAEb,aAAO,MAAM;AACX,cAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,YAAI,KAAM;AAEV,kBAAU,QAAQ,OAAO,OAAO,EAAE,QAAQ,KAAK,CAAC;AAChD,cAAM,QAAQ,OAAO,MAAM,IAAI;AAC/B,iBAAS,MAAM,IAAI,KAAK;AAExB,mBAAW,QAAQ,OAAO;AACxB,cAAI,KAAK,WAAW,QAAQ,GAAG;AAC7B,kBAAM,OAAO,KAAK,MAAM,CAAC;AACzB,gBAAI,SAAS,UAAU;AACrB,oBAAM,EAAE,SAAS,IAAI,MAAM,KAAK;AAChC;AAAA,YACF;AACA,gBAAI;AACF,oBAAM,SAAS,KAAK,MAAM,IAAI;AAC9B,oBAAM,UAAU,OAAO,QAAQ,CAAC,GAAG,OAAO,WAAW;AACrD,oBAAM,SAAS,OAAO,QAAQ,CAAC,GAAG,kBAAkB;AACpD,oBAAM,EAAE,SAAS,MAAM,OAAO;AAAA,YAChC,QAAQ;AAAA,YAER;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AACF;;;ACvJA,IAAM,mBAAmB;AAsBlB,IAAM,mBAAN,cAA+B,eAAe;AAAA,EAC1C,eAA2B;AAAA,EAC3B,kBAAkB;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACS,eAAe;AAAA,EAExB,MAAM,SACJ,UACA,SAC2B;AAC3B,QAAI;AACF,YAAM,MAAM,MAAM,MAAM,kBAAkB;AAAA,QACxC,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,eAAe,UAAU,KAAK,MAAM;AAAA,QACtC;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,OAAO,KAAK;AAAA,UACZ,UAAU,SAAS,IAAI,CAAC,OAAO;AAAA,YAC7B,MAAM,EAAE;AAAA,YACR,SAAS,EAAE;AAAA,UACb,EAAE;AAAA,UACF,aAAa,SAAS,eAAe,KAAK;AAAA,UAC1C,YAAY,SAAS,aAAa,KAAK;AAAA,UACvC,MAAM,SAAS;AAAA,QACjB,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,IAAI,IAAI;AACX,cAAM,QAAQ,MAAM,IAAI,KAAK;AAC7B,cAAM,IAAI,MAAM,uBAAuB,KAAK,EAAE;AAAA,MAChD;AAEA,YAAM,WAAY,MAAM,IAAI,KAAK;AACjC,YAAM,SAAS,SAAS,QAAQ,CAAC;AAEjC,aAAO;AAAA,QACL,SAAS,OAAO,SAAS,WAAW;AAAA,QACpC,OAAO,SAAS,SAAS,KAAK;AAAA,QAC9B,OAAO;AAAA,UACL,cAAc,SAAS,OAAO,iBAAiB;AAAA,UAC/C,kBAAkB,SAAS,OAAO,qBAAqB;AAAA,UACvD,aAAa,SAAS,OAAO,gBAAgB;AAAA,QAC/C;AAAA,QACA,cAAc,OAAO,iBAAiB;AAAA,MACxC;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,OACL,UACA,SAC6B;AAC7B,QAAI;AACF,YAAM,MAAM,MAAM,MAAM,kBAAkB;AAAA,QACxC,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,eAAe,UAAU,KAAK,MAAM;AAAA,QACtC;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,OAAO,KAAK;AAAA,UACZ,UAAU,SAAS,IAAI,CAAC,OAAO;AAAA,YAC7B,MAAM,EAAE;AAAA,YACR,SAAS,EAAE;AAAA,UACb,EAAE;AAAA,UACF,aAAa,SAAS,eAAe,KAAK;AAAA,UAC1C,YAAY,SAAS,aAAa,KAAK;AAAA,UACvC,MAAM,SAAS;AAAA,UACf,QAAQ;AAAA,QACV,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,IAAI,IAAI;AACX,cAAM,QAAQ,MAAM,IAAI,KAAK;AAC7B,cAAM,IAAI,MAAM,uBAAuB,KAAK,EAAE;AAAA,MAChD;AAEA,YAAM,SAAS,IAAI,MAAM,UAAU;AACnC,UAAI,CAAC,OAAQ,OAAM,IAAI,MAAM,kBAAkB;AAE/C,YAAM,UAAU,IAAI,YAAY;AAChC,UAAI,SAAS;AAEb,aAAO,MAAM;AACX,cAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,YAAI,KAAM;AAEV,kBAAU,QAAQ,OAAO,OAAO,EAAE,QAAQ,KAAK,CAAC;AAChD,cAAM,QAAQ,OAAO,MAAM,IAAI;AAC/B,iBAAS,MAAM,IAAI,KAAK;AAExB,mBAAW,QAAQ,OAAO;AACxB,cAAI,KAAK,WAAW,QAAQ,GAAG;AAC7B,kBAAM,OAAO,KAAK,MAAM,CAAC;AACzB,gBAAI,SAAS,UAAU;AACrB,oBAAM,EAAE,SAAS,IAAI,MAAM,KAAK;AAChC;AAAA,YACF;AACA,gBAAI;AACF,oBAAM,SAAS,KAAK,MAAM,IAAI;AAC9B,oBAAM,UAAU,OAAO,QAAQ,CAAC,GAAG,OAAO,WAAW;AACrD,oBAAM,SAAS,OAAO,QAAQ,CAAC,GAAG,kBAAkB;AACpD,oBAAM,EAAE,SAAS,MAAM,OAAO;AAAA,YAChC,QAAQ;AAAA,YAER;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AACF;;;AC5IO,IAAM,iBAAN,cAA6B,eAAe;AAAA,EACxC,eAA2B;AAAA,EAC3B,kBAAkB;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACS,eAAe;AAAA,EAEhB;AAAA,EAER,YAAY,QAAgB,OAAgB,aAAsB,WAAoB;AAEpF,UAAM,QAAQ,OAAO,aAAa,SAAS;AAC3C,SAAK,UAAU,UAAU;AAAA,EAC3B;AAAA,EAEA,MAAM,SACJ,UACA,SAC2B;AAC3B,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,aAAa;AAAA,QACvD,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAC9C,MAAM,KAAK,UAAU;AAAA,UACnB,OAAO,KAAK;AAAA,UACZ,UAAU,SAAS,IAAI,CAAC,OAAO;AAAA,YAC7B,MAAM,EAAE;AAAA,YACR,SAAS,EAAE;AAAA,UACb,EAAE;AAAA,UACF,SAAS;AAAA,YACP,aAAa,SAAS,eAAe,KAAK;AAAA,YAC1C,aAAa,SAAS,aAAa,KAAK;AAAA,YACxC,MAAM,SAAS;AAAA,UACjB;AAAA,UACA,QAAQ;AAAA,QACV,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,IAAI,MAAM,QAAQ,SAAS,MAAM,KAAK,SAAS,UAAU,EAAE;AAAA,MACnE;AAEA,YAAM,OAAQ,MAAM,SAAS,KAAK;AAElC,aAAO;AAAA,QACL,SAAS,KAAK,QAAQ;AAAA,QACtB,OAAO,KAAK;AAAA,QACZ,OAAO;AAAA,UACL,cAAc,KAAK,qBAAqB;AAAA,UACxC,kBAAkB,KAAK,cAAc;AAAA,UACrC,cAAc,KAAK,qBAAqB,MAAM,KAAK,cAAc;AAAA,QACnE;AAAA,QACA,cAAc;AAAA,MAChB;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,OACL,UACA,SAC6B;AAC7B,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,aAAa;AAAA,QACvD,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAC9C,MAAM,KAAK,UAAU;AAAA,UACnB,OAAO,KAAK;AAAA,UACZ,UAAU,SAAS,IAAI,CAAC,OAAO;AAAA,YAC7B,MAAM,EAAE;AAAA,YACR,SAAS,EAAE;AAAA,UACb,EAAE;AAAA,UACF,SAAS;AAAA,YACP,aAAa,SAAS,eAAe,KAAK;AAAA,YAC1C,aAAa,SAAS,aAAa,KAAK;AAAA,YACxC,MAAM,SAAS;AAAA,UACjB;AAAA,UACA,QAAQ;AAAA,QACV,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,IAAI,MAAM,QAAQ,SAAS,MAAM,KAAK,SAAS,UAAU,EAAE;AAAA,MACnE;AAEA,YAAM,SAAS,SAAS,MAAM,UAAU;AACxC,UAAI,CAAC,QAAQ;AACX,cAAM,IAAI,MAAM,kBAAkB;AAAA,MACpC;AAEA,YAAM,UAAU,IAAI,YAAY;AAEhC,aAAO,MAAM;AACX,cAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,YAAI,KAAM;AAEV,cAAM,OAAO,QAAQ,OAAO,OAAO,EAAE,QAAQ,KAAK,CAAC;AACnD,cAAM,QAAQ,KAAK,MAAM,IAAI,EAAE,OAAO,OAAO;AAE7C,mBAAW,QAAQ,OAAO;AACxB,cAAI;AACF,kBAAM,OAAuB,KAAK,MAAM,IAAI;AAC5C,kBAAM;AAAA,cACJ,SAAS,KAAK,SAAS,WAAW;AAAA,cAClC,MAAM,KAAK;AAAA,YACb;AAAA,UACF,QAAQ;AAAA,UAER;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AACF;;;AChIO,SAAS,eAAe,QAA0C;AACvE,QAAM,EAAE,UAAU,QAAQ,OAAO,aAAa,UAAU,IAAI;AAE5D,UAAQ,UAAU;AAAA,IAChB,KAAK;AACH,aAAO,IAAI,eAAe,QAAQ,OAAO,aAAa,SAAS;AAAA,IAEjE,KAAK;AACH,aAAO,IAAI,kBAAkB,QAAQ,OAAO,aAAa,SAAS;AAAA,IAEpE,KAAK;AACH,aAAO,IAAI,eAAe,QAAQ,OAAO,aAAa,SAAS;AAAA,IAEjE,KAAK;AACH,aAAO,IAAI,aAAa,QAAQ,OAAO,aAAa,SAAS;AAAA,IAE/D,KAAK;AACH,aAAO,IAAI,iBAAiB,QAAQ,OAAO,aAAa,SAAS;AAAA,IAEnE,KAAK;AACH,aAAO,IAAI,eAAe,QAAQ,OAAO,aAAa,SAAS;AAAA,IAEjE,KAAK;AAEH,aAAO,IAAI,eAAe,QAAQ,SAAS,iBAAiB,aAAa,SAAS;AAAA,IAEpF,KAAK;AAEH,aAAO,IAAI,eAAe,QAAQ,SAAS,wBAAwB,aAAa,SAAS;AAAA,IAE3F;AACE,YAAM,IAAI,MAAM,4BAA4B,QAAQ,EAAE;AAAA,EAC1D;AACF;AAKO,SAAS,mBAAmB,UAAgC;AACjE,QAAM,SAAuC;AAAA,IAC3C,QAAQ,CAAC,UAAU,eAAe,eAAe,SAAS,iBAAiB,cAAc,SAAS;AAAA,IAClG,WAAW,CAAC,8BAA8B,6BAA6B,0BAA0B,4BAA4B,yBAAyB;AAAA,IACtJ,QAAQ,CAAC,wBAAwB,kBAAkB,oBAAoB,uBAAuB,YAAY;AAAA,IAC1G,MAAM,CAAC,2BAA2B,2BAA2B,wBAAwB,sBAAsB,cAAc;AAAA,IACzH,UAAU,CAAC,iDAAiD,gDAAgD,yCAAyC,iCAAiC;AAAA,IACtL,QAAQ,CAAC,YAAY,YAAY,WAAW,WAAW,aAAa,QAAQ,UAAU,SAAS;AAAA,IAC/F,UAAU,CAAC,iBAAiB,gBAAgB;AAAA,IAC5C,SAAS,CAAC,wBAAwB,yBAAyB,wBAAwB,kBAAkB;AAAA,EACvG;AAEA,SAAO,OAAO,QAAQ,KAAK,CAAC;AAC9B;AAKO,SAAS,gBAAgB,UAA8B;AAC5D,QAAM,WAAuC;AAAA,IAC3C,QAAQ;AAAA,IACR,WAAW;AAAA,IACX,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,SAAS;AAAA,EACX;AAEA,SAAO,SAAS,QAAQ,KAAK;AAC/B;;;ACnFA,IAAM,wBAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBvB,IAAM,gBAAN,MAAoB;AAAA,EACjB;AAAA,EACA;AAAA,EACA;AAAA,EACA,sBAAiC,CAAC;AAAA,EAClC,gBAA6C,oBAAI,IAAI;AAAA,EACrD,YAAY;AAAA,EAEpB,YAAY,gBAAwB,QAAqB;AACvD,SAAK,SAAS;AACd,SAAK,SAAS,IAAI,eAAe,EAAE,QAAQ,eAAe,CAAC;AAC3D,SAAK,aAAa,eAAe,OAAO,UAAU;AAGlD,SAAK,oBAAoB,KAAK;AAAA,MAC5B,MAAM;AAAA,MACN,SAAS,OAAO,gBAAgB;AAAA,IAClC,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAMA,GAAG,OAAe,SAA6B;AAC7C,UAAM,WAAW,KAAK,cAAc,IAAI,KAAK,KAAK,CAAC;AACnD,aAAS,KAAK,OAAO;AACrB,SAAK,cAAc,IAAI,OAAO,QAAQ;AAAA,EACxC;AAAA,EAEA,IAAI,OAAe,SAA6B;AAC9C,UAAM,WAAW,KAAK,cAAc,IAAI,KAAK,KAAK,CAAC;AACnD,UAAM,QAAQ,SAAS,QAAQ,OAAO;AACtC,QAAI,QAAQ,IAAI;AACd,eAAS,OAAO,OAAO,CAAC;AACxB,WAAK,cAAc,IAAI,OAAO,QAAQ;AAAA,IACxC;AAAA,EACF;AAAA,EAEQ,KAAK,OAAyB;AACpC,UAAM,WAAW,KAAK,cAAc,IAAI,MAAM,IAAI,KAAK,CAAC;AACxD,UAAM,cAAc,KAAK,cAAc,IAAI,GAAG,KAAK,CAAC;AAEpD,KAAC,GAAG,UAAU,GAAG,WAAW,EAAE,QAAQ,CAAC,YAAY;AACjD,UAAI;AACF,gBAAQ,KAAK;AAAA,MACf,SAAS,OAAO;AACd,gBAAQ,MAAM,wBAAwB,KAAK;AAAA,MAC7C;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,KAAK,SAAkC;AAC3C,SAAK,KAAK;AAAA,MACR,MAAM;AAAA,MACN,WAAW,oBAAI,KAAK;AAAA,MACpB,MAAM,EAAE,QAAQ;AAAA,IAClB,CAAC;AAGD,SAAK,oBAAoB,KAAK;AAAA,MAC5B,MAAM;AAAA,MACN,SAAS;AAAA,IACX,CAAC;AAGD,UAAM,mBAAmB,MAAM,KAAK,yBAAyB,OAAO;AAGpE,UAAM,sBAAsB,KAAK,wBAAwB,gBAAgB;AAEzE,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,WAAW,SAAS,mBAAmB;AAGjE,WAAK,oBAAoB,KAAK;AAAA,QAC5B,MAAM;AAAA,QACN,SAAS,OAAO;AAAA,MAClB,CAAC;AAED,WAAK,KAAK;AAAA,QACR,MAAM;AAAA,QACN,WAAW,oBAAI,KAAK;AAAA,QACpB,MAAM;AAAA,UACJ,UAAU,OAAO;AAAA,UACjB,OAAO,OAAO;AAAA,UACd,OAAO,OAAO;AAAA,QAChB;AAAA,MACF,CAAC;AAGD,UAAI,KAAK,OAAO,aAAa,KAAK,uBAAuB,SAAS,OAAO,OAAO,GAAG;AACjF,cAAM,KAAK,iBAAiB,SAAS,OAAO,OAAO;AAAA,MACrD;AAEA,aAAO,OAAO;AAAA,IAChB,SAAS,OAAO;AACd,WAAK,KAAK;AAAA,QACR,MAAM;AAAA,QACN,WAAW,oBAAI,KAAK;AAAA,QACpB,MAAM,EAAE,MAAM;AAAA,MAChB,CAAC;AACD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,WAAW,SAAyC;AACzD,SAAK,KAAK;AAAA,MACR,MAAM;AAAA,MACN,WAAW,oBAAI,KAAK;AAAA,MACpB,MAAM,EAAE,QAAQ;AAAA,IAClB,CAAC;AAED,SAAK,oBAAoB,KAAK;AAAA,MAC5B,MAAM;AAAA,MACN,SAAS;AAAA,IACX,CAAC;AAED,UAAM,mBAAmB,MAAM,KAAK,yBAAyB,OAAO;AACpE,UAAM,sBAAsB,KAAK,wBAAwB,gBAAgB;AAEzE,QAAI,eAAe;AAEnB,QAAI;AACF,uBAAiB,SAAS,KAAK,WAAW,OAAO,mBAAmB,GAAG;AACrE,wBAAgB,MAAM;AACtB,cAAM,MAAM;AAAA,MACd;AAEA,WAAK,oBAAoB,KAAK;AAAA,QAC5B,MAAM;AAAA,QACN,SAAS;AAAA,MACX,CAAC;AAED,WAAK,KAAK;AAAA,QACR,MAAM;AAAA,QACN,WAAW,oBAAI,KAAK;AAAA,QACpB,MAAM,EAAE,UAAU,aAAa;AAAA,MACjC,CAAC;AAED,UAAI,KAAK,OAAO,aAAa,KAAK,uBAAuB,SAAS,YAAY,GAAG;AAC/E,cAAM,KAAK,iBAAiB,SAAS,YAAY;AAAA,MACnD;AAAA,IACF,SAAS,OAAO;AACd,WAAK,KAAK;AAAA,QACR,MAAM;AAAA,QACN,WAAW,oBAAI,KAAK;AAAA,QACpB,MAAM,EAAE,MAAM;AAAA,MAChB,CAAC;AACD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,yBAAyB,OAAkC;AACvE,QAAI;AACF,YAAM,WAAW,MAAM,KAAK,OAAO,eAAe,OAAO,CAAC;AAC1D,aAAO,SAAS,UAAW,SAAS,QAAQ,CAAC,IAAK,CAAC;AAAA,IACrD,QAAQ;AACN,aAAO,CAAC;AAAA,IACV;AAAA,EACF;AAAA,EAEQ,wBAAwB,UAA+B;AAC7D,UAAM,WAAW,CAAC,GAAG,KAAK,mBAAmB;AAE7C,QAAI,SAAS,SAAS,GAAG;AACvB,YAAM,gBAAgB,SACnB,IAAI,CAAC,MAAM,YAAY,EAAE,KAAK;AAAA,EAAM,EAAE,OAAO,EAAE,EAC/C,KAAK,MAAM;AAGd,YAAM,gBAAgB,SAAS,SAAS;AACxC,eAAS,OAAO,eAAe,GAAG;AAAA,QAChC,MAAM;AAAA,QACN,SAAS;AAAA;AAAA,EAAkD,aAAa;AAAA,MAC1E,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,uBAAuB,aAAqB,mBAAoC;AAEtF,UAAM,cAAc,YAAY,SAAS,kBAAkB;AAC3D,UAAM,eAAe,cAAc;AACnC,UAAM,aAAa,YAAY,SAAS,GAAG;AAC3C,UAAM,cAAc,uDAAuD,KAAK,iBAAiB;AAEjG,WAAO,iBAAiB,cAAc;AAAA,EACxC;AAAA,EAEA,MAAc,iBAAiB,aAAqB,mBAA0C;AAC5F,QAAI;AACF,YAAM,KAAK,YAAY;AAAA,QACrB,YAAY;AAAA,QACZ,OAAO,YAAY,MAAM,GAAG,GAAG;AAAA,QAC/B,SAAS,SAAS,WAAW;AAAA;AAAA,aAAkB,iBAAiB;AAAA,QAChE,YAAY;AAAA,QACZ,MAAM,CAAC,gBAAgB,aAAa;AAAA,QACpC,UAAU;AAAA,UACR,QAAQ;AAAA,UACR,OAAO,KAAK,WAAW,SAAS;AAAA,QAClC;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,cAAQ,MAAM,qCAAqC,KAAK;AAAA,IAC1D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,OAAkD;AAClE,UAAM,WAAW,MAAM,KAAK,OAAO,YAAY,KAAK;AAEpD,QAAI,SAAS,WAAW,SAAS,MAAM;AACrC,WAAK,KAAK;AAAA,QACR,MAAM;AAAA,QACN,WAAW,oBAAI,KAAK;AAAA,QACpB,MAAM,SAAS;AAAA,MACjB,CAAC;AACD,aAAO,SAAS;AAAA,IAClB;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,QAAQ,IAAuB;AAC/C,UAAM,WAAW,MAAM,KAAK,OAAO,aAAa,EAAE,MAAM,CAAC;AACzD,WAAO,SAAS,UAAW,SAAS,MAAM,SAAS,CAAC,IAAK,CAAC;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,OAAe,QAAQ,IAAuB;AACjE,UAAM,WAAW,MAAM,KAAK,OAAO,eAAe,OAAO,KAAK;AAC9D,WAAO,SAAS,UAAW,SAAS,QAAQ,CAAC,IAAK,CAAC;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,kBAAkB,QAAQ,IAAmC;AACjE,UAAM,WAAW,MAAM,KAAK,OAAO,kBAAkB,EAAE,MAAM,CAAC;AAC9D,WAAO,SAAS,UAAW,SAAS,MAAM,SAAS,CAAC,IAAK,CAAC;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,WAAqC;AACxD,UAAM,WAAW,MAAM,KAAK,OAAO,eAAe,EAAE,UAAU,CAAC;AAE/D,QAAI,SAAS,SAAS;AACpB,WAAK,KAAK;AAAA,QACR,MAAM;AAAA,QACN,WAAW,oBAAI,KAAK;AAAA,QACpB,MAAM,SAAS;AAAA,MACjB,CAAC;AACD,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAAW,UAAkB,UAAoC;AACrE,UAAM,WAAW,MAAM,KAAK,OAAO,cAAc,EAAE,UAAU,SAAS,CAAC;AAEvE,QAAI,SAAS,SAAS;AACpB,WAAK,KAAK;AAAA,QACR,MAAM;AAAA,QACN,WAAW,oBAAI,KAAK;AAAA,QACpB,MAAM,SAAS;AAAA,MACjB,CAAC;AACD,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,eAAqB;AACnB,SAAK,sBAAsB,CAAC,KAAK,oBAAoB,CAAC,CAAC;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA,EAKA,aAAwB;AACtB,WAAO,CAAC,GAAG,KAAK,mBAAmB;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,QAAsB;AACpC,SAAK,oBAAoB,CAAC,IAAI;AAAA,MAC5B,MAAM;AAAA,MACN,SAAS;AAAA,IACX;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,YAA4B;AAC1B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,WAAmB;AACjB,WAAO,KAAK,WAAW,SAAS;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,OAAqB;AAC5B,SAAK,WAAW,SAAS,KAAK;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,gBACJ,QACA,aAAa,KACE;AACf,SAAK,YAAY;AAEjB,WAAO,KAAK,WAAW;AACrB,UAAI;AACF,cAAM,OAAO,IAAI;AAAA,MACnB,SAAS,OAAO;AACd,aAAK,KAAK;AAAA,UACR,MAAM;AAAA,UACN,WAAW,oBAAI,KAAK;AAAA,UACpB,MAAM,EAAE,MAAM;AAAA,QAChB,CAAC;AAAA,MACH;AAEA,UAAI,KAAK,WAAW;AAClB,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,UAAU,CAAC;AAAA,MAChE;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,OAAa;AACX,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,eAAwB;AACtB,WAAO,KAAK;AAAA,EACd;AACF;","names":[]}